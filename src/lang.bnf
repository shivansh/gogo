/* Lexical part */

// separator  : ',' | ':' ;
terminator : ';' '\n' | ';' | '\n' ;

/* Keywords */
kwdBreak    : 'b' 'r' 'e' 'a' 'k' ;
kwdCase     : 'c' 'a' 's' 'e' ;
kwdConst    : 'c' 'o' 'n' 's' 't' ;
kwdContinue : 'c' 'o' 'n' 't' 'i' 'n' 'u' 'e' ;
kwdDefault  : 'd' 'e' 'f' 'a' 'u' 'l' 't' ;
kwdElse     : 'e' 'l' 's' 'e' ;
kwdFunc     : 'f' 'u' 'n' 'c' ;
kwdFor      : 'f' 'o' 'r' ;
kwdGoto     : 'g' 'o' 't' 'o' ;
kwdIf       : 'i' 'f' ;
kwdImport   : 'i' 'm' 'p' 'o' 'r' 't' ;
kwdPackage  : 'p' 'a' 'c' 'k' 'a' 'g' 'e' ;
kwdRange    : 'r' 'a' 'n' 'g' 'e' ;
kwdRet      : 'r' 'e' 't' 'u' 'r' 'n' ;
kwdStruct   : 's' 't' 'r' 'u' 'c' 't' ;
kwdSwitch   : 's' 'w' 'i' 't' 'c' 'h' ;
kwdType     : 't' 'y' 'p' 'e' ;
kwdVar      : 'v' 'a' 'r' ;

/* Types */
type : 'b' 'o' 'o' 'l'
     | 'i' 'n' 't' | 'f' 'l' 'o' 'a' 't' '3' '2' | 'f' 'l' 'o' 'a' 't' '6' '4'
     | 'b' 'y' 't' 'e'
     | 's' 't' 'r' 'i' 'n' 'g'
     ;

/* Predeclared contants */
boolLit : 't' 'r' 'u' 'e' | 'f' 'a' 'l' 's' 'e' ;

/* Operators */
_relOp      : '=' '=' | '!' '=' | '<' | '<' '=' | '>' | '>' '=' ;
_addOp      : '+' | '-' | '|' | '^' ;
_mulOp      : '*' | '/' | '%' | '<' '<' | '>' '>' | '&' | '&' '^' ;
assignOp    : [ _addOp | _mulOp ] '=' ;
shortAssign : ':' '=' ;
// dotOp       : '.' ;

/* Whitespaces (suppressed) */
!whitespace : ' ' | '\t' | '\r' ;

/* Comments (suppressed) */
!comment      : _lineComment | _blockComment ;
_lineComment  : '/' '/' { . } '\n' ;
_blockComment : '/' '*' { . | '*' } '*' '/' ;

/* Letters and digits */
_letter        : _unicodeLetter | '_' ;
_unicodeLetter : 'a' - 'z' | 'A' - 'Z' ;
_decimalDigit  : '0' - '9' ;
_octalDigit    : '0' - '7' ;
_hexDigit      : _decimalDigit | 'a' - 'f' | 'A' - 'F' ;

/* Identifiers */
// TODO: Check this
// blankIdent : '_' ;
identifier : _letter { _letter | _decimalDigit } ;

/* Integer literals */
intLit      : _decimalLit | _octalLit | _hexLit ;
_decimalLit : '1' - '9' { _decimalDigit } ;
_octalLit   : '0' { _octalDigit } ;
_hexLit     : '0' ( 'x' | 'X' ) _hexDigit { _hexDigit } ;

/* Floating-point literals */
floatLit  : _decimals '.' [ _decimals ] [ _exponent ]
          | _decimals _exponent
          | '.' _decimals [ _exponent ]
          ;
_decimals : _decimalDigit { _decimalDigit } ;
_exponent : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

/* String literals */
stringLit          :  _rawStrLit | _interpretedStrLit ;
_rawStrLit         : '`' { . } '`' ;
_interpretedStrLit : '"' { . | '\\' '"' | _escapeChar } '"' ;
/* Single-character escapes */
_escapeChar : '\\' 'n' | '\\' 'r' | '\\' 't' ;

/* Rune literals */
runeLit  : '\'' [ '\\' ] [ . ] '\'' ;

/* Syntax part */

<<
import(
        "errors"
        "fmt"
        "regexp"
        "strconv"
        "strings"

        "github.com/shivansh/gogo/src/utils"
        "github.com/shivansh/gogo/tmp/token"
)

// Node represents a node in the AST of a given program.
type Node struct {
	place string   // variable storing the value if node represents an expression
	code  []string // IR instructions
}

type symTabType map[string][]string

type SymInfo struct {
	varSymTab symTabType
	parent    *SymInfo
}

// DeferStackItem is an individual item stored when a call to defer is made. It
// contains the code for the corresponding function call which is placed at the
// end of function body.
type DeferStackItem []string

var (
	tmpIndex   int
	labelIndex int
	varIndex   int
	// funcSymtabCreated keeps track whether a symbol table corresponding to a
	// function declaration has to be instantiated. This is because usually
	// a new symbol table is created when the corresponding block begins.
	// However, in case of functions the arguments also need to be added to
	// the symbol table. Thus the symbol table is instantiated when the
	// production rule corresponding to the arguments is reached and not
	// when the block begins.
	funcSymtabCreated bool
	symTab            symTabType // symbol table for temporaries ; TODO: Update this.
	// currSymTab keeps track of the currently active symbol table
	// depending on scope.
	currSymTab *SymInfo
	// globalSymTab keeps track of the global struct and function declarations.
	// NOTE: structs and functions can only be declared globally.
	globalSymTab symTabType
	// deferStack stores the deferred function calls which are then called
	// when the surrounding function block ends.
	deferStack *utils.Stack
	re         *regexp.Regexp
)

func init() {
	symTab = make(symTabType)
	globalSymTab = make(symTabType)
	deferStack = utils.CreateStack()
	re = regexp.MustCompile("(^-?[0-9]+$)") // integers
}

// SearchInScope returns the symbol table entry for a given variable in the
// current scope. If not found, the parent symbol table is looked up until the
// topmost symbol table is reached. If not found in all these symbol tables,
// then the global symbol table is looked up which contains the entries
// corresponding to structs and functions.
func SearchInScope(v string) ([]string, bool) {
	currScope := currSymTab
	for currScope != nil {
		symTabEntry, ok := currScope.varSymTab[v]
		if ok {
			return symTabEntry, true
		} else {
			currScope = currSymTab.parent
		}
	}
	// Lookup in global scope in case the variable corresponds to a struct
	// or a function name.
	for k, symTabEntry := range globalSymTab {
		if k == v {
			return symTabEntry, true
		}
	}
	return []string{}, false
}

// GetRealName extracts the original name of variable from its renamed version.
func GetRealName(s string) string {
	realName := ""
	for i := 0; i < len(s); i++ {
		if s[i] == '.' {
			break
		} else {
			realName = realName + string(s[i])
		}
	}
	return realName
}

// NewTmp generates a unique temporary variable.
func NewTmp() string {
	t := fmt.Sprintf("t%d", tmpIndex)
	tmpIndex++
	return t
}

// NewLabel generates a unique label name.
func NewLabel() string {
	l := fmt.Sprintf("l%d", labelIndex)
	labelIndex++
	return l
}

// NewVar generates a unique variable name used for renaming. A variable named
// var will be renamed to 'var.int_lit' where int_lit is an integer. Since
// variable names cannot contain a '.', this will not result in a naming
// conflict with an existing variable. The renamed variable will only occur in
// the IR (there is no constraint on variable names in IR as of now).
func RenameVariable(v string) string {
	ret := fmt.Sprintf("%s.%d", v, varIndex)
	varIndex++
	return ret
}
>>

// NOTE: https://github.com/goccmack/gocc/issues/5998

// SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
Start : SourceFile
        << func() (Attrib, error) {
	        re := regexp.MustCompile("\n(\n)*")
                c := $0.(Node).code
                for _, v := range c {
                        v := strings.TrimSpace(v)
                        // Compress multiple newlines within IR statements into
                        // a single newline.
                        v = re.ReplaceAllString(v, "\n")
                        if v != "" {
                                fmt.Println(v)
                        }
                }
                return nil, nil
        } () >>
      ;

// SourceFile : PackageClause terminator RepeatTerminator RepeatImportDecl RepeatTopLevelDecl
SourceFile : RepeatTopLevelDecl
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
           ;

// RepeatImportDecl : ImportDecl terminator RepeatTerminator RepeatImportDecl
//                         << func() (Attrib, error) {
//                                 n := Node{"", []string{}}
//                                 n.code = append(n.code, $0.(Node).code...)
//                                 n.code = append(n.code, $3.(Node).code...)
//                                 n.code = append(n.code, "\n")
//                                 return nil, nil
//                         } () >>
//                  | empty
//                         << func() (Attrib, error) {
//                                 n := Node{"", []string{}}
//                                 return n, nil
//                         } () >>
//                  ;
//
// // ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
// // ImportSpec       = [ "." | PackageName ] ImportPath .
// // ImportPath       = string_lit .
// ImportDecl : kwdImport ImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdImport ImportSpec");
//                         return nil, nil
//                 } () >>
//            | kwdImport "(" RepeatImportSpec ")"
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdImport \"(\" RepeatImportSpec \")\"");
//                         return nil, nil
//                 } () >>
//            ;
//
// RepeatImportSpec : ImportSpec terminator RepeatImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("ImportSpec terminator RepeatImportSpec");
//                         return nil, nil
//                 } () >>
//                  | empty
//                 << func() (Attrib, error) {
//                         fmt.Println("empty");
//                         return nil, nil
//                 } () >>
//                 // TODO: '\n' can follow "import (", but a ';' cannot as opposed to go's grammar.
//                  | terminator RepeatImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("terminator RepeatImportSpec");
//                         return nil, nil
//                 } () >>
//                  ;
//
// ImportSpec : ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("ImportPath");
//                         return nil, nil
//                 } () >>
//            | "." ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("\".\" ImportPath");
//                         return nil, nil
//                 } () >>
//            | PackageName ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("PackageName ImportPath");
//                         return nil, nil
//                 } () >>
//            ;
//
// ImportPath : stringLit
//                 << func() (Attrib, error) {
//                       fmt.Println("stringLit");
//                       return nil, nil
//                 } () >>
//            ;
//
// PackageClause : kwdPackage PackageName
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdPackage PackageName");
//                         return nil, nil
//                 } () >>
//               ;
//
// PackageName : identifier
//                 << func() (Attrib, error) {
//                         fmt.Println("identifier");
//                         return nil, nil
//                 } () >>
//             ;

// TODO: MethodDecl is not supported at the moment.
// TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
RepeatTopLevelDecl : TopLevelDecl RepeatTopLevelDecl
                        << func() (Attrib, error) {
                              n := Node{"", $0.(Node).code}
                              n.code = append(n.code, $1.(Node).code...)
                              return n, nil
                        } () >>
                   | empty
                        << func() (Attrib, error) {
                              return Node{"", []string{}}, nil
                        } () >>
                   ;

TopLevelDecl : Declaration RepeatTerminator
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
             | FunctionDecl RepeatTerminator
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
             ;

// Declaration = ConstDecl | TypeDecl | VarDecl .
Declaration : ConstDecl
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
            | TypeDecl
                    << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                    } () >>
            | VarDecl
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
            ;

// VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
// VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
VarDecl : kwdVar VarSpec
            << func() (Attrib, error) {
                    return Node{"", $1.(Node).code}, nil
            } () >>
//         | kwdVar "(" RepeatTerminator RepeatVarSpec ")"
//             << func() (Attrib, error) {
//                   fmt.Println("kwdVar \"(\" RepeatTerminator RepeatVarSpec \")\"");
//                   return nil, nil
//             } () >>
        ;
//
// // VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
// RepeatVarSpec : VarSpec terminator RepeatTerminator RepeatVarSpec
//                 << func() (Attrib, error) {
//                       fmt.Println("VarSpec terminator RepeatTerminator RepeatVarSpec");
//                       return nil, nil
//                 } () >>
//               | VarSpec RepeatTerminator
//                 << func() (Attrib, error) {
//                       fmt.Println("VarSpec RepeatTerminator");
//                       return nil, nil
//                 } () >>
//               ;
//
VarSpec : IdentifierList Type
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        for _, v := range $0.(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
                                n.code = append(n.code, fmt.Sprintf("=, %s, 0", renamedVar))
                        }
                        return n, nil
                } () >>
        | IdentifierList Type "=" ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", $3.(Node).code}
                        expr := utils.SplitAndSanitize($3.(Node).place, ",")
                        for k, v := range $0.(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
                        }
                        return n, nil
                } () >>
        | IdentifierList "=" ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", $2.(Node).code}
                        expr := utils.SplitAndSanitize($2.(Node).place, ",")
                        for k, v := range $0.(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
                        }
                        return n, nil
                } () >>
        | empty
                << func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>
        ;

// TypeDecl  = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
// TypeSpec  = AliasDecl | TypeDef .
// AliasDecl = identifier "=" Type
// TypeDef   = identifier Type
TypeDecl : kwdType TypeSpec
                << func() (Attrib, error) {
                        typeInfo := utils.SplitAndSanitize($1.(Node).place, ",")
                        structName := strings.TrimSpace(typeInfo[1])
                        switch strings.TrimSpace(typeInfo[0]) {
                        case "struct":
                                // Create a global symbol table entry.
                                // NOTE: The symbol table entry of a struct is of the form -
                                //      structName : []{"struct", memberName1, memberType1, memberName2, memberType2, ...}
                                globalSymTab[structName] = []string{"struct"}
                                globalSymTab[structName] = append(globalSymTab[structName], $1.(Node).code...)
                        default: // TODO: Add remaining types.
                                return nil, errors.New("Unknown type")
                        }
                        // TODO: Member initialization will be done when a new object is instantiated.
                        return Node{"", []string{}}, nil
                } () >>
//          | kwdType "(" RepeatTerminator RepeatTypeSpec ")"
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdType \"(\" RepeatTerminator RepeatTypeSpec \")\"");
//                         return nil, nil
//                 } () >>
         ;
//
// RepeatTypeSpec : TypeSpec terminator RepeatTerminator RepeatTypeSpec
//                     << func() (Attrib, error) {
//                             fmt.Println("TypeSpec terminator RepeatTerminator RepeatTypeSpec");
//                             return nil, nil
//                     } () >>
//                | TypeSpec RepeatTerminator
//                     << func() (Attrib, error) {
//                             fmt.Println("TypeSpec RepeatTerminator");
//                             return nil, nil
//                     } () >>
//                ;
//
TypeSpec : TypeDef
            << func() (Attrib, error) {
                return Node{$0.(Node).place, $0.(Node).code}, nil
            } () >>
//          |    AliasDecl
//             << func() (Attrib, error) {
//                     fmt.Println("AliasDecl");
//                     return nil, nil
//             } () >>
//          | empty
//             << func() (Attrib, error) {
//                     fmt.Println("empty");
//                     return nil, nil
//             } () >>
         ;
//
// AliasDecl : identifier "=" Type
//             << func() (Attrib, error) {
//                     fmt.Println("identifier \"=\" Type");
//                     return nil, nil
//             } () >>
//           ;

TypeDef : identifier Type
             << func() (Attrib, error) {
                    return Node{fmt.Sprintf("%s, %s", $1.(Node).place, string($0.(*token.Token).Lit)), $1.(Node).code}, nil
             } () >>
        ;

// ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
// ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .
// IdentifierList = identifier { "," identifier } .
// ExpressionList = Expression { "," Expression } .
ConstDecl : kwdConst ConstSpec
                << func() (Attrib, error) {
                        return Node{"", $1.(Node).code}, nil
                } () >>
          // | kwdConst "(" RepeatTerminator RepeatConstSpec ")"
          //   << func() (Attrib, error) {
          //           fmt.Println("kwdConst \"(\" RepeatTerminator RepeatConstSpec \")\"");
          //           return nil, nil
          //   } () >>
          ;

// RepeatConstSpec : ConstSpec terminator RepeatTerminator RepeatConstSpec
//                 << func() (Attrib, error) {
//                       fmt.Println("ConstSpec terminator RepeatTerminator RepeatConstSpec");
//                       return nil, nil
//                 } () >>
//                 | ConstSpec RepeatTerminator
//                 << func() (Attrib, error) {
//                       fmt.Println("ConstSpec RepeatTerminator");
//                       return nil, nil
//                 } () >>
//                 ;

ConstSpec : IdentifierList
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        for _, v := range $0.(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"} // TODO: Handle other types
                                n.code = append(n.code, fmt.Sprintf("=, %s, 0", renamedVar))
                        }
                        return n, nil
                } () >>
          | IdentifierList "=" ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", $2.(Node).code}
                        expr := utils.SplitAndSanitize($2.(Node).place, ",")
                        for k, v := range $0.(Node).code {
                                renamedVar := RenameVariable(v)
                                currSymTab.varSymTab[v] = []string{renamedVar, "int"}
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
                        }
                        return n, nil
                } () >>
          // | IdentifierList Type "=" ExpressionList
          //       << func() (Attrib, error) {
          //               fmt.Println("IdentifierList Type \"=\" ExpressionList");
          //               return nil, nil
          //       } () >>
          // | empty
          //       << func() (Attrib, error) {
          //               fmt.Println("empty");
          //               return nil, nil
          //       } () >>
          ;

ExpressionList : Expression
                        << func() (Attrib, error) {
                                return Node{$0.(Node).place, $0.(Node).code}, nil
                        } () >>
               | Expression "," ExpressionList
                        << func() (Attrib, error) {
                                n := Node{"", $0.(Node).code}
                                n.code = append(n.code, $2.(Node).code...)
                                n.place = fmt.Sprintf("%s,%s", $0.(Node).place, $2.(Node).place)
                                return n, nil
                        } () >>
               ;

// Expression = UnaryExpr | Expression binary_op Expression .
// NOTE: The original BNF corresponding to Expression is modified to take into
// account operator precedence. The operators used are in the order of
// increasing precedence starting from top.
Expression : Expression "||" Term1
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("or, %s, %s, %s", n.place, $0.(Node).place, $2.(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>
           | Term1
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
           ;

Term1 : Term1 "&&" Term2
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("and, %s, %s, %s", n.place, $0.(Node).place, $2.(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>
        | Term2
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
        ;

Term2 : Term2 RelOp Term3
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        branchOp := ""
                        n.place = NewTmp()
                        falseLabel := NewLabel()
                        afterLabel := NewLabel()
                        switch $1.(Node).place {
                                case "==":
                                        branchOp = "bne"
                                case "!=":
                                        branchOp = "beq"
                                case "<=":
                                        branchOp = "bgt"
                                case "<":
                                        branchOp = "bge"
                                case ">=":
                                        branchOp = "blt"
                                case ">":
                                        branchOp = "ble"
                        }
                        n.code = append(n.code, fmt.Sprintf("%s, %s, %s, %s", branchOp, falseLabel, $0.(Node).place, $2.(Node).place))
                        n.code = append(n.code, fmt.Sprintf("=, %s, 1", n.place))
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", falseLabel))
                        n.code = append(n.code, fmt.Sprintf("=, %s, 0", n.place))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
        | Term3
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
        ;

Term3 : Term3 "+" Term4
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        if re.MatchString($0.(Node).place) && re.MatchString($2.(Node).place) {
                                // expression is of the form 1+2
                                term3val, err := strconv.Atoi($0.(Node).place)
                                if err != nil {
                                        return nil, err
                                }
                                term4val, err := strconv.Atoi($2.(Node).place)
                                if err != nil {
                                        return nil, err
                                }
                                n.place = strconv.Itoa(term3val + term4val)
                        } else if re.MatchString($0.(Node).place) {
                                // expression is of the form 1+b, which is to be converted to b+1
                                n.place = NewTmp()
                                n.code = append(n.code, fmt.Sprintf("+, %s, %s, %s", n.place, $2.(Node).place, $0.(Node).place))
                                n.code = append(n.code, "\n")
                        } else {
                                n.place = NewTmp()
                                n.code = append(n.code, fmt.Sprintf("+, %s, %s, %s", n.place, $0.(Node).place, $2.(Node).place))
                                n.code = append(n.code, "\n")
                        }
                        return n, nil
                } () >>
        | Term4
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
        ;

Term4 : Term4 "-" Term5
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("-, %s, %s, %s", n.place, $0.(Node).place, $2.(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>
      | Term5
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
      ;

Term5 : Term5 "*" Term6
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("*, %s, %s, %s", n.place, $0.(Node).place, $2.(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>
      | Term6
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
      ;

Term6 : Term6 "/" Term7
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("/, %s, %s, %s", n.place, $0.(Node).place, $2.(Node).place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>
      | Term7
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
      ;

Term7 : "(" Expression ")"
                << func() (Attrib, error) {
                        return Node{$1.(Node).place, $1.(Node).code}, nil
                } () >>
      | UnaryExpr
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
      ;

// TODO: Add support for booleans in IR.
BinaryOp : RelOp
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                } () >>
         | "||"
                << func() (Attrib, error) {
                        return Node{"or", []string{}}, nil
                } () >>
         | "&&"
                << func() (Attrib, error) {
                        return Node{"and", []string{}}, nil
                } () >>
         ;

// unaryOp will be used for defining UnaryExpr in parser.
// unaryOp     : '+' | '-' | '!' | '^' | '*' | '&' | '<' '-' ;
// binaryOp    : '|' '|' | '&' '&' | _relOp | _addOp | _mulOp ;
RelOp : "=="
        << func() (Attrib, error) {
                return Node{"==", []string{}}, nil
        } () >>
      | "!="
        << func() (Attrib, error) {
                return Node{"!=", []string{}}, nil
        } () >>
      | "<="
        << func() (Attrib, error) {
                return Node{"<=", []string{}}, nil
        } () >>
      | "<"
        << func() (Attrib, error) {
                return Node{"<", []string{}}, nil
        } () >>
      | ">="
        << func() (Attrib, error) {
                return Node{">=", []string{}}, nil
        } () >>
      | ">"
        << func() (Attrib, error) {
                return Node{">", []string{}}, nil
        } () >>
      ;

// UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .
UnaryExpr : PrimaryExpr
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
          | UnaryOp UnaryExpr
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        n.code = append(n.code, $1.(Node).code...)
                        switch $0.(Node).place {
                        case "-":
                                n.place = NewTmp()
                                n.code = append(n.code, fmt.Sprintf("*, %s, %s, -1", n.place, $1.(Node).place))
                        case "!":
                                n.place = NewTmp()
                                n.code = append(n.code, fmt.Sprintf("not, %s, %s", n.place, $1.(Node).place))
                        case "+":
                                n.place = $1.(Node).place
                        case "&":
                                // Place of any pointer variable starts with "pointer:" and then followed by string returned by NewTmp()
                                n.place = "pointer:" + $1.(Node).place
                        case "*":
                                n.place = "deref:" + $1.(Node).place
                        default:
                                return n, errors.New(fmt.Sprintf("%s operator not supported", $0.(Node).place))
                        }
                        return n, nil
                } () >>
          ;

UnaryOp : "+"
              << func() (Attrib, error) {
                    return Node{"+", []string{}}, nil
              } () >>
        | "-"
              << func() (Attrib, error) {
                    return Node{"-", []string{}}, nil
              } () >>
        | "!"
              << func() (Attrib, error) {
                    return Node{"!", []string{}}, nil
              } () >>
//         | "^"
//               << func() (Attrib, error) {
//                     fmt.Println("\"^\"");
//                     return nil, nil
//               } () >>
       | "*"
             << func() (Attrib, error) {
                   return Node{"*", []string{}}, nil
             } () >>
       | "&"
             << func() (Attrib, error) {
                   return Node{"&", []string{}}, nil
             } () >>
//         | "<-"
//               << func() (Attrib, error) {
//                     fmt.Println("\"<-\"");
//                     return nil, nil
//               } () >>
        ;

// PrimaryExpr =
//  Operand |
//  Conversion |
//  MethodExpr |
//  PrimaryExpr Selector |
//  PrimaryExpr Index |
//  PrimaryExpr Slice |
//  PrimaryExpr TypeAssertion |
//  PrimaryExpr Arguments .
PrimaryExpr : Operand
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
//             | Conversion
//                 << func() (Attrib, error) {
//                       fmt.Println("Conversion");
//                       return nil, nil
//                 } () >>
            | PrimaryExpr Selector
                    << func() (Attrib, error) {
                          varName := fmt.Sprintf("%s.%s", $0.(Node).place, $1.(Node).place)
                          symTabEntry, found := SearchInScope(varName)
                          if found {
                                if _, ok := globalSymTab[varName]; ok {
                                            return nil, errors.New(fmt.Sprintf("%s not in scope", varName) )
                                   } else {
                                            return Node{symTabEntry[0], []string{}}, nil
                                   }
                          } else {
                                 return nil, errors.New(fmt.Sprintf("%s not in scope", varName) )
                          }
                    } () >>

            | PrimaryExpr Index
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        n.place = NewTmp()
                        // TODO: Write comment here.
                        symTab[n.place] = []string{fmt.Sprintf("%s, %s", $0.(Node).place, $1.(Node).place), "array"}
                        n.code = append(n.code, $1.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("from, %s, %s, %s", n.place, $0.(Node).place, $1.(Node).place))
                        return n, nil
                } () >>
//             | PrimaryExpr Slice
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr Slice");
//                       return nil, nil
//                 } () >>
//             | PrimaryExpr TypeAssertion
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr TypeAssertion");
//                       return nil, nil
//                 } () >>
            | PrimaryExpr Arguments
                // This is the production rule for a function call.
                << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        typeName := globalSymTab[$0.(Node).place][0]
                        var returnLength int
                        if len(typeName) >= 5 && typeName[:4] == "func" {
                                returnLength, _ = strconv.Atoi(typeName[5:])
                        } else {
                                return nil, errors.New(fmt.Sprintf("%s not a function", $0.(Node).place))
                        }
                        argExpr := utils.SplitAndSanitize($1.(Node).place, ",")
                        for k, v := range argExpr {
                              n.code = append(n.code, fmt.Sprintf("=, %s.%d, %s", $0.(Node).place, k, v))
                        }
                        n.code = append(n.code, fmt.Sprintf("call, %s", $0.(Node).place))
                        for k:=0 ; k < returnLength ; k++ {
                                n.place = fmt.Sprintf("%s, return.%d", n.place, k)
                        }

                        // n.code = append(n.code, fmt.Sprintf("store, %s", n.place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>
            ;

// Operand     = Literal | OperandName | "(" Expression ")" .
// Literal     = BasicLit | CompositeLit | FunctionLit .
// BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
// OperandName = identifier | QualifiedIdent.
Operand : Literal
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
        | OperandName
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                } () >>
//         | "(" Expression ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Expression \")\"");
//                       return nil, nil
//                 } () >>
        ;

Literal : BasicLit
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                } () >>
        | CompositeLit
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
//         | FunctionLit
//                 << func() (Attrib, error) {
//                       fmt.Println("FunctionLit");
//                       return nil, nil
//                 } () >>
        ;

BasicLit : intLit
                << func() (Attrib, error) {
                        return Node{string($0.(*token.Token).Lit), []string{}}, nil
                } () >>
//          | floatLit
//                 << func() (Attrib, error) {
//                       fmt.Println("floatLit");
//                       return nil, nil
//                 } () >>
//          | runeLit
//                 << func() (Attrib, error) {
//                       fmt.Println("runeLit");
//                       return nil, nil
//                 } () >>
//          | stringLit
//                 << func() (Attrib, error) {
//                       fmt.Println("stringLit");
//                       return nil, nil
//                 } () >>
//          | boolLit
//                << func() (Attrib, error) {
//                      fmt.Println("boolLit");
//                      return nil, nil
//                } () >>
         ;

// CompositeLit  = LiteralType LiteralValue .
// LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
//                 SliceType | MapType | TypeName .
// LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
// ElementList   = KeyedElement { "," KeyedElement } .
// KeyedElement  = [ Key ":" ] Element .
// Key           = FieldName | Expression | LiteralValue .
// FieldName     = identifier .
// Element       = Expression | LiteralValue .
CompositeLit : LiteralType LiteralValue
                        << func() (Attrib, error) {
                                // NOTE: Structs don't support initialization of members
                                // currently. All data members are initialized to default
                                // values when a struct instance is defined.
                                n := Node{$0.(Node).place, []string{}}
                                // Check if the LiteralType corresponds to ArrayType.
                                // This is done because unlike structs it is not required
                                // to add a symbol table entry for place value of arrays
                                // (which is of the form "array:<length_of_array>"), thus
                                // returning early.
                                typeName := $0.(Node).place
                                if len(typeName) >= 5 && typeName[:5] == "array" {
                                        return n, nil
                                }
                                // In case the corresponds to a struct, add the
                                // code for its data member initialization.
                                symTabEntry, found := SearchInScope($0.(Node).place)
                                if found {
                                        switch symTabEntry[0] {
                                        case "struct":
                                                // The place value for struct is of the form -
                                                //      struct:<number of members of struct>:<name of struct>
                                                n.place = fmt.Sprintf("struct:%d:%s", (len(symTabEntry)-1) / 2, n.place)
                                                litVals := utils.SplitAndSanitize($1.(Node).place, ",")
                                                litValCodes := $1.(Node).code
                                                structInit := []string{}
                                                // In case of integral (or any type) initializations, the corresponding
                                                // lexeme is placed at the place value, justifying the length check which
                                                // is made on 'litVals' instead of 'litValCodes'. If there are no place
                                                // values for the data members, then initialize all to their default
                                                // values. Otherwise initialize them to the corresponding place value.
                                                if len(litVals) == 0 {
                                                        for k, v := range symTabEntry[1:] {
                                                                if k % 2 == 0 {
                                                                        structInit = append(structInit, v)
                                                                        // TODO: Update default values depending on type
                                                                        structInit = append(structInit, "0")
                                                                }
                                                        }
                                                } else {
                                                        for k, v := range symTabEntry[1:] {
                                                                if k % 2 == 0 {
                                                                        structInit = append(structInit, v)
                                                                        structInit = append(structInit, litVals[k / 2])
                                                                }
                                                        }
                                                }
                                                // When these code values will be utilized above, the litValCodes will be
                                                // placed above the code corresponding to structInit (litVals can be expressions).
                                                n.code = append(n.code, structInit...)
                                                n.code = append(n.code, litValCodes...)
                                        }
                                } else {
                                        // TODO: Update error message.
                                        return nil, errors.New(fmt.Sprintf("%s not in scope", $0.(Node).place))
                                }
                                return n, nil
                        } () >>
             ;

LiteralType : ArrayType
                        << func() (Attrib, error) {
                                return Node{$0.(Node).place, []string{}}, nil
                        } () >>
            // | StructType
            //             << func() (Attrib, error) {
            //                     return Node{$0.(Node).place, []string{}}, nil
            //             } () >>
            // | "[" "..." "]" ElementType
//                     << func() (Attrib, error) {
//                           fmt.Println("\"[\" \"...\" \"]\" ElementType");
//                           return nil, nil
//                     } () >>
//
//             | SliceType
//                   << func() (Attrib, error) {
//                         fmt.Println("SliceType");
//                         return nil, nil
//                   } () >>
//             | type
//                   << func() (Attrib, error) {
//                         fmt.Println("type");
//                         return nil, nil
//                   } () >>
            // When initializing structs, TypeName will be used as the name of struct.
            | TypeName
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
            ;
// TypeName  = identifier | QualifiedIdent .
// QualifiedIdent = PackageName "." identifier .
TypeName : identifier
                << func() (Attrib, error) {
                        return Node{string($0.(*token.Token).Lit), []string{}}, nil
                } () >>
         // | type
         ;

LiteralValue : "{" RepeatTerminator "}"
                        << func() (Attrib, error) {
                                return Node{"", []string{}}, nil
                        } () >>
             // NOTE: We don't support adding a ',' after the last KeyedElement
             // as opposed to the official go language.
             // TODO: Support for struct initialization.
             | "{" RepeatTerminator ElementList "}"
                        << func() (Attrib, error) {
                                return Node{$2.(Node).place, $2.(Node).code}, nil
                        } () >>
             ;

ElementList : KeyedElement RepeatKeyedElement
                << func() (Attrib, error) {
                        n := Node{fmt.Sprintf("%s, %s", $0.(Node).place, $1.(Node).place), $0.(Node).code}
                        n.code = append(n.code, $1.(Node).code...)
                        return n, nil
                } () >>
            ;

RepeatKeyedElement : "," RepeatTerminator KeyedElement RepeatKeyedElement
                        << func() (Attrib, error) {
                                n := Node{fmt.Sprintf("%s, %s", $2.(Node).place, $3.(Node).place), $2.(Node).code}
                                n.code = append(n.code, $3.(Node).code...)
                                return n, nil
                        } () >>
                   | RepeatTerminator
                        << func() (Attrib, error) {
                                return Node{"", []string{}}, nil
                        } () >>
//                    // | "," RepeatTerminator
//                    //      << func() (Attrib, error) {
//                    //            fmt.Println("\",\" RepeatTerminator");
//                    //            return nil, nil
//                    //      } () >>
//                    // | empty
//                    //      << func() (Attrib, error) {
//                    //            fmt.Println("empty");
//                    //            return nil, nil
//                    //      } () >>
                   ;

KeyedElement : Element
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
//              | Key ":" Element
//                 << func() (Attrib, error) {
//                         fmt.Println("Key \":\" Element");
//                         return nil, nil
//                 } () >>
             ;
//
// Key : FieldName
//         << func() (Attrib, error) {
//               fmt.Println("FieldName");
//               return nil, nil
//         } () >>
//     | Expression
//         << func() (Attrib, error) {
//               fmt.Println("Expression");
//               return nil, nil
//         } () >>
//     | LiteralValue
//         << func() (Attrib, error) {
//               fmt.Println("LiteralValue");
//               return nil, nil
//         } () >>
//     ;
//
// FieldName : identifier
//                 << func() (Attrib, error) {
//                       fmt.Println("identifier");
//                       return nil, nil
//                 } () >>
          // ;

Element : Expression
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
//         | LiteralValue
//                 << func() (Attrib, error) {
//                       fmt.Println("LiteralValue");
//                       return nil, nil
//                 } () >>
        ;
//
// // FunctionLit = "func" Signature FunctionBody .
// FunctionLit : kwdFunc Signature FunctionBody
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdFunc Signature FunctionBody");
//                       return nil, nil
//                 } () >>
//             ;

OperandName : identifier
                << func() (Attrib, error) {
                        // return Node{string($0.(*token.Token).Lit), []string{}}, nil
                        varName := string($0.(*token.Token).Lit)
                        symTabEntry, found := SearchInScope(varName)
                        if found {
                        	if _, ok := globalSymTab[varName]; ok {
                        		return Node{varName, []string{}}, nil
                        	} else {
                                        return Node{symTabEntry[0], []string{}}, nil
                        	}
                        } else {
                        	return nil, errors.New(fmt.Sprintf("%s not declared", varName))
                        }
                } () >>
            ;

// // Selector       = "." identifier .
// // Index          = "[" Expression "]" .
// // Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
// //                  "[" [ Expression ] ":" Expression ":" Expression "]" .
// // TypeAssertion  = "." "(" Type ")" .
// // Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
// // Conversion = Type "(" Expression [ "," ] ")"
Selector : "." identifier
                << func() (Attrib, error) {
                        return Node{string($1.(*token.Token).Lit), []string{}}, nil
                } () >>
         ;

Index : "[" Expression "]"
                << func() (Attrib, error) {
                        return Node{$1.(Node).place, $1.(Node).code}, nil
                } () >>
      ;

// Slice : "[" ":" "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" \":\" \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" Expression ":" "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \":\" \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" Expression ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" ":" Expression ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" \":\" Expression \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" Expression ":" Expression ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \":\" Expression \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       ;
//
// TypeAssertion : "." "(" Type ")"
//               << func() (Attrib, error) {
//                     fmt.Println("\".\" \"(\" Type \")\"");
//                     return nil, nil
//               } () >>
//               ;

// Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
// NOTE: Since compilation of local variables has not yet been done, only empty
// arguments are supported for the time being.
Arguments : "(" ")"
              << func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>
          | "(" ExpressionList ")"
                << func() (Attrib, error) {
                      return Node{$1.(Node).place, $1.(Node).code}, nil
                } () >>
//           | "(" ExpressionList "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" ExpressionList "..." ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \"...\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" ExpressionList "..." "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \"...\" \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "..." ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \"...\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "..." "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \"...\" \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList "..." ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \"...\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList "..." "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \"...\" \",\" \")\"");
//                       return nil, nil
//                 } () >>
          ;
//
// Conversion : Type "(" Expression ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("Type \"(\" Expression \")\"");
//                       return nil, nil
//                 } () >>
//            | Type "(" Expression "," ")"
//                << func() (Attrib, error) {
//                      fmt.Println("Type \"(\" Expression \",\" \")\"");
//                      return nil, nil
//                } () >>
//            ;

// FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .
// FunctionName = identifier .
// FunctionBody = Block .
// NOTE: To support recursion, we need to add function's symbol table entry before
// the production rule for block of its body is reached. This is to avoid errors
// of the form "funcion not declared". A marker is introduced for the same.
FunctionDecl : FunctionMarker FunctionBody
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $1.(Node).code...)
                        funcSymtabCreated = false // end of function block
                        // Return statement insertion will be handled when defer
                        // stack is emptied and the deferred calls are inserted.
                        addRetStmt := false
                        if deferStack.Len > 0 {
                                addRetStmt = true
                        }
                        for deferStack.Len > 0 {
                                deferFuncCode := deferStack.Pop().(DeferStackItem)
                                n.code = append(n.code, deferFuncCode...)
                        }
                        if addRetStmt {
                                n.code = append(n.code, fmt.Sprintf("ret,"))
                        }
                        return n, nil
                } () >>
             // TODO Handle function declarations without body.
             // | kwdFunc FunctionName Signature
             ;

FunctionMarker : kwdFunc FunctionName Signature
                << func() (Attrib, error) {
                        n := Node{$1.(Node).place, []string{fmt.Sprintf("func, %s", $1.(Node).place)}}
                        // Assign values to arguments.
                        for k, v := range $2.(Node).code {
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s.%d", v, $1.(Node).place, k))
                        }
                        if _, found := globalSymTab[$1.(Node).place]; !found {
                                globalSymTab[$1.(Node).place] = []string{fmt.Sprintf("func:%s", $2.(Node).place)}
                        } else {
                                return nil, errors.New(fmt.Sprintf("Function %s already declared\n", string($0.(*token.Token).Lit)))
                        }
                        return n, nil
                } () >>
                ;

// Signature      = Parameters [ Result ] .
// Result         = Parameters | Type .
// Parameters     = "(" [ ParameterList [ "," ] ] ")" .
// ParameterList  = ParameterDecl { "," ParameterDecl } .
// ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
Signature : Parameters
            << func() (Attrib, error) {
                      // The parent symbol table in case of function declaration
                      // will be nil as functions can only be declared globally.
                      childSymTab := SymInfo{make(symTabType), currSymTab}
                      // Update the current symbol table to point to the newly
                      // created symbol table.
                      currSymTab = &childSymTab
                      for _, v := range $0.(Node).code {
                            if v == "" {
                                  break
                            }
                            currSymTab.varSymTab[v] = []string{v, "int"}
                      }
                      return Node{"0", $0.(Node).code}, nil
                } () >>

           | Parameters Result
                 << func() (Attrib, error) {
                       // The parent symbol table in case of function declaration
                       // will be nil as functions can only be declared globally.
                       childSymTab := SymInfo{make(symTabType), currSymTab}
                       // Update the current symbol table to point to the newly
                       // created symbol table.
                       currSymTab = &childSymTab
                       for _, v := range $0.(Node).code {
                             if v == "" {
                                   break
                             }
                             currSymTab.varSymTab[v] = []string{v, "int"}
                       }
                       return Node{fmt.Sprintf("%s", $1.(Node).place), $0.(Node).code}, nil
                 } () >>
          ;

Result : Parameters
              << func() (Attrib, error) {
                    returnLength := 0
                    // finding number of return variable
                    for _, v := range $0.(Node).code {
                            if v == "int" {
                                    returnLength ++
                            }
                    }
                    return Node{fmt.Sprintf("%d", returnLength), []string{}}, nil
              } () >>
       | Type
              << func() (Attrib, error) {
                    return Node{"1", []string{}}, nil
              } () >>
       ;

// TODO: Ignore terminator
// TODO: Parameters cannot end in ','
Parameters : "(" RepeatTerminator ")"
                  << func() (Attrib, error) {
                      return Node{"", []string{}}, nil
                } () >>
           | "(" ParameterList ")"
                << func() (Attrib, error) {
                      return Node{"", $1.(Node).code}, nil
                } () >>
           ;

ParameterList : ParameterDecl RepeatParameterDecl
                << func() (Attrib, error) {
                      n := Node{"", $0.(Node).code}
                      n.code = append(n.code, $1.(Node).code...)
                      return n, nil
                } () >>
              ;
//
RepeatParameterDecl : "," ParameterDecl RepeatParameterDecl
                        << func() (Attrib, error) {
                              n := Node{"", $1.(Node).code}
                              n.code = append(n.code, $2.(Node).code...)
                              return n, nil
                        } () >>
                        | empty
                        << func() (Attrib, error) {
                              return Node{"", []string{}}, nil
                        } () >>
                    ;
//
ParameterDecl : IdentifierList Type
                << func() (Attrib, error) {
                      return Node{"", $0.(Node).code}, nil
                } () >>
                | Type
                << func() (Attrib, error) {
                      return Node{"", []string{fmt.Sprintf("int")}}, nil
                } () >>
//                 | "..." Type
//                 << func() (Attrib, error) {
//                       fmt.Println("\"...\" Type");
//                       return nil, nil
//                 } () >>
//                 | IdentifierList "..." Type
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList \"...\" Type");
//                       return nil, nil
//                 } () >>
              ;

// Type      = TypeName | TypeLit | "(" Type ")" .
// TypeName  = identifier | QualifiedIdent .
// TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
//             SliceType | MapType | ChannelType .
Type : type
        << func() (Attrib, error) {
              return Node{string($0.(*token.Token).Lit), []string{}}, nil
        } () >>
//       | identifier
//         << func() (Attrib, error) {
//                 fmt.Println("identifier");
//                 return nil, nil
//         } () >>
      | TypeLit
        << func() (Attrib, error) {
              return Node{$0.(Node).place, $0.(Node).code}, nil
        } () >>
//       | "(" Type ")"
//         << func() (Attrib, error) {
//               fmt.Println("\"(\" Type \")\"");
//               return nil, nil
//         } () >>
     ;

TypeLit : StructType
                << func() (Attrib, error) {
                        return Node{"struct", $0.(Node).code}, nil
                } () >>
        // | ArrayType
        // << func() (Attrib, error) {
        //       fmt.Println("StructType");
        //       return nil, nil
        // } () >>
//         | PointerType
//         << func() (Attrib, error) {
//               fmt.Println("PointerType");
//               return nil, nil
//         } () >>
//         | FunctionType
//         << func() (Attrib, error) {
//               fmt.Println("FunctionType");
//               return nil, nil
//         } () >>
//         | SliceType
//         << func() (Attrib, error) {
//               fmt.Println("SliceType");
//               return nil, nil
//         } () >>
        ;

// ArrayType   = "[" ArrayLength "]" ElementType .
// ArrayLength = Expression .
// ElementType = Type .
ArrayType : "[" ArrayLength "]" ElementType
                << func() (Attrib, error) {
                        // TODO: ElementType is taken to be only int for now.
                        return Node{fmt.Sprintf("array:%s", $1.(Node).place), []string{}}, nil
                } () >>
          ;

// NOTE: ArrayLength is modified to be only an integer, unlike in Go where it is
// an expression.
ArrayLength : intLit
                << func() (Attrib, error) {
                        return Node{string($0.(*token.Token).Lit), []string{}}, nil
                } () >>
            ;

ElementType : Type
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                } () >>
            ;

// StructType    = kwdStruct "{" { FieldDecl ";" } "}" .
// FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
// EmbeddedField = [ "*" ] TypeName .
// Tag           = string_lit .
StructType : kwdStruct RepeatTerminator "{" RepeatTerminator RepeatFieldDecl "}"
                << func() (Attrib, error) {
                        return Node{"", $4.(Node).code}, nil
                } () >>
           ;

RepeatFieldDecl : FieldDecl terminator RepeatTerminator RepeatFieldDecl
                        << func() (Attrib, error) {
                                n := Node{"", $0.(Node).code}
                                n.code = append(n.code, $3.(Node).code...)
                                return n, nil
                        } () >>
                | FieldDecl RepeatTerminator
                        << func() (Attrib, error) {
                                return Node{"", $0.(Node).code}, nil
                        } () >>
                ;

FieldDecl : IdentifierList Type
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        for _, v := range $0.(Node).code {
                                n.code = append(n.code, v)
                                n.code = append(n.code, $1.(Node).place)
                        }
                        return n, nil
                } () >>
//           | IdentifierList Type Tag
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList Type Tag");
//                       return nil, nil
//                 } () >>
//           | EmbeddedField
//                 << func() (Attrib, error) {
//                       fmt.Println("EmbeddedField");
//                       return nil, nil
//                 } () >>
//           | EmbeddedField Tag
//                 << func() (Attrib, error) {
//                       fmt.Println("EmbeddedField Tag");
//                       return nil, nil
//                 } () >>
          | empty
                << func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>
          ;

// EmbeddedField : type
//                 << func() (Attrib, error) {
//                       fmt.Println("type");
//                       return nil, nil
//                 } () >>
//               | "*" type
//                 << func() (Attrib, error) {
//                       fmt.Println("\"*\" type");
//                       return nil, nil
//                 } () >>
//               ;
//
// Tag : stringLit
//         << func() (Attrib, error) {
//               fmt.Println("stringLit");
//               return nil, nil
//         } () >>
//     ;
//
// // PointerType = "*" BaseType .
// // BaseType    = Type .
// PointerType : "*" BaseType
//                 << func() (Attrib, error) {
//                       fmt.Println("\"*\" BaseType");
//                       return nil, nil
//                 } () >>
//             ;
//
// BaseType : Type
//                 << func() (Attrib, error) {
//                       fmt.Println("Type");
//                       return nil, nil
//                 } () >>
//          ;
//
// // FunctionType   = "func" Signature .
// // Signature      = Parameters [ Result ] .
// // Result         = Parameters | Type .
// // Parameters     = "(" [ ParameterList [ "," ] ] ")" .
// // ParameterList  = ParameterDecl { "," ParameterDecl } .
// // ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
// FunctionType : kwdFunc Signature
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdFunc Signature");
//                       return nil, nil
//                 } () >>
//              ;
//
// // SliceType = "[" "]" ElementType .
// SliceType : "[" "]" ElementType
//                 << func() (Attrib, error) {
//                       fmt.Println("\"[\" \"]\" ElementType");
//                       return nil, nil
//                 } () >>
//           ;

// IdentifierList = identifier { "," identifier } .
IdentifierList : identifier
                        << func() (Attrib, error) {
                                return Node{"", []string{string($0.(*token.Token).Lit)}}, nil
                        } () >>
               | identifier "," IdentifierList
                        << func() (Attrib, error) {
                                // The lexemes corresponding to the individual identifiers
                                // are appended to the slice for code to avoid adding
                                // comma-separated string in place since the identifiers
                                // don't have any IR code to be added.
                                n := Node{"", []string{string($0.(*token.Token).Lit)}}
                                n.code = append(n.code, $2.(Node).code...)
                                return n, nil
                        } () >>
               ;

FunctionName : identifier
                << func() (Attrib, error) {
                        // The symbol table entry for a function is of the form -
                        //      functionName : ["func", (rest of the values are yet to be decided)]

                        return Node{string($0.(*token.Token).Lit), []string{}}, nil
                 } () >>
              ;

FunctionBody : Block
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
             ;

RepeatTerminator : terminator RepeatTerminator
                 | empty
                 ;

StatementList : Statement terminator RepeatTerminator StatementList
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $3.(Node).code...)
                        return n, nil
                } () >>
              | Statement RepeatTerminator
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
              ;

// Statement = Declaration | LabeledStmt | SimpleStmt |
//             GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
//             FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
//             DeferStmt .
// NOTE: The following additional statements are introduced.
// PrintIntStmt
Statement : Declaration
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
          | LabeledStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
          | SimpleStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
          | ReturnStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
          | BreakStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
          | ContinueStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
          | GotoStmt
                << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
                } () >>
          // TODO: FallthroughStmt is not supported currently.
          | Block
                << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
                } () >>
          | IfStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
          | SwitchStmt
                << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
                } () >>
          | ForStmt
                << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
                } () >>
          | DeferStmt
                << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
                } () >>
          | PrintIntStmt
                << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
                } () >>
          ;

// LabeledStmt = Label ":" Statement .
// Label       = identifier .
LabeledStmt : Label ":" RepeatTerminator Statement
                << func() (Attrib, error) {
                        n := Node{"", []string{fmt.Sprintf("label, %s", $0.(Node).place)}}
                        n.code = append(n.code, $3.(Node).code...)
                        return n, nil
                } () >>
            ;

// SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
// EmptyStmt = .
// ExpressionStmt = Expression .
// IncDecStmt = Expression ( "++" | "--" ) .
// Assignment = ExpressionList assign_op ExpressionList .
// assign_op = [ add_op | mul_op ] "=" .
// ShortVarDecl = IdentifierList ":=" ExpressionList .
SimpleStmt : EmptyStmt
                << func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>
           | Assignment
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
           | ShortVarDecl
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
           | IncDecStmt
                << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
                } () >>
           ;

// SimpleStmt : ExpressionStmt
//                 << func() (Attrib, error) {
//                       fmt.Println("ExpressionStmt");
//                       return nil, nil
//                 } () >>
//            | Assignment
//                << func() (Attrib, error) {
//                      fmt.Println("Assignment");
//                      return nil, nil
//                } () >>
//            | ShortVarDecl
//                << func() (Attrib, error) {
//                      fmt.Println("ShortVarDecl");
//                      return nil, nil
//                } () >>
//            | EmptyStmt
//                << func() (Attrib, error) {
//                      fmt.Println("EmptyStmt");
//                      return nil, nil
//                } () >>
//            ;

EmptyStmt : empty ;

ReturnStmt : kwdRet
                << func() (Attrib, error) {
                        // The defer statements need to be inserted before the return stmt (and
                        // not at the end of function block as was the previous misconception).
                        // When defer stmt is used, the return stmt for main() is also inserted
                        // when all the defer calls from stack are popped and inserted in IR.
                        if deferStack.Len > 0 {
                                // Return statement insertion will be handled when defer
                                // stack is emptied and the deferred calls are inserted.
                                return Node{"", []string{}}, nil
                        } else {
                                return Node{"", []string{"ret,"}}, nil
                        }
                } () >>
           | kwdRet ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        if deferStack.Len == 0 {
                                retExpr := utils.SplitAndSanitize($1.(Node).place, ",")
                                n.code = append(n.code, $1.(Node).code...)
                                for k, v := range retExpr {
                                      n.code = append(n.code, fmt.Sprintf("=, return.%d, %s", k, v))
                                }
                                n.code = append(n.code, fmt.Sprintf("ret,"))
                        }
                        return n, nil
                } () >>
           ;

// BreakStmt = "break" [ Label ] .
BreakStmt : kwdBreak
                << func() (Attrib, error) {
                        return Node{"", []string{"break"}}, nil
                } () >>
          | kwdBreak Label
                << func() (Attrib, error) {
                        return Node{"", []string{fmt.Sprintf("j, %s", $1.(Node).place)}}, nil
                } () >>
          ;

// ContinueStmt = "continue" [ Label ] .
ContinueStmt : kwdContinue
                << func() (Attrib, error) {
                        return Node{"", []string{"continue"}}, nil
                } () >>
             // TODO: `continue label` vs `break label` ??
             // | kwdContinue Label
             //    << func() (Attrib, error) {
             //          fmt.Println("kwdContinue Label");
             //          return nil, nil
             //    } () >>
              ;

// GotoStmt = "goto" Label .
GotoStmt : kwdGoto Label
                << func() (Attrib, error) {
                        return Node{"", []string{fmt.Sprintf("j, %s", $1.(Node).place)}}, nil
                } () >>
         ;

Block : "{" Marker RepeatTerminator StatementList "}"
                << func() (Attrib, error) {
                        // start of block
                        if  currSymTab.parent != nil {
                                currSymTab = currSymTab.parent // end of block
                        } else {
                                currSymTab = nil
                        }
                        return Node{"", $3.(Node).code}, nil
                } () >>
      ;

// NOTE: Marker demarcates the beginning of a block and the corresponding symbol
// table is instantiated here.
Marker : empty
                << func() (Attrib, error) {
                        if funcSymtabCreated {
                                // The symbol table for functions is created when the
                                // rule for Signature is reached so that the arguments
                                // can also be added. At this point the function block
                                // (if there was any) has completed.
                                childSymTab := SymInfo{make(symTabType), currSymTab}
                                // Update the current symbol table to point to the newly
                                // created symbol table.
                                currSymTab = &childSymTab
                        } else {
                                // Allow creation of symbol table for another function.
                                funcSymtabCreated = true
                        }
                        return nil, nil
                } () >>
        ;

// IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .
IfStmt : kwdIf Expression Block
                << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, $1.(Node).place))
                        n.code = append(n.code, $2.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>
        | kwdIf Expression Block kwdElse Block
                << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        elseLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, $1.(Node).place))
                        n.code = append(n.code, $2.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
                        n.code = append(n.code, $4.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
        | kwdIf Expression Block kwdElse IfStmt
                << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        elseLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, $1.(Node).place))
                        n.code = append(n.code, $2.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
                        n.code = append(n.code, $4.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
       | kwdIf SimpleStmt terminator Expression Block
                << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        afterLabel := NewLabel()
                        n.code = append(n.code, $3.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, $3.(Node).place))
                        n.code = append(n.code, $4.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
       | kwdIf SimpleStmt terminator Expression Block kwdElse IfStmt
                << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        elseLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, $3.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, $3.(Node).place))
                        n.code = append(n.code, $4.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
                        n.code = append(n.code, $6.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil

                } () >>
        | kwdIf SimpleStmt terminator Expression Block kwdElse Block
                << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        elseLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, $3.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, $3.(Node).place))
                        n.code = append(n.code, $4.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
                        n.code = append(n.code, $6.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
       ;

// SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
SwitchStmt : ExprSwitchStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
//            | TypeSwitchStmt
//                << func() (Attrib, error) {
//                      fmt.Println("TypeSwitchStmt");
//                      return nil, nil
//                } () >>
           ;

// ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
// ExprCaseClause = ExprSwitchCase ":" StatementList .
// ExprSwitchCase = "case" ExpressionList | "default" .
        ExprSwitchStmt : kwdSwitch Expression "{" RepeatTerminator RepeatExprCaseClause "}"
                        << func() (Attrib, error) {
                                n := Node{"", $1.(Node).code}
                                caseLabels := []string{}
                                caseStmts := $4.(Node).code
                                caseTemporaries := utils.SplitAndSanitize($4.(Node).place, ",")
                                afterLabel := NewLabel()
                                defaultLabel := afterLabel
                                // The last value in caseTemporaries will be the place value
                                // returned by Empty (arising from RepeatExprCaseClause -> Empty).
                                // This has to be ignored.
                                for k, v := range caseTemporaries[:len(caseTemporaries)-1] {
                                        caseLabel := NewLabel()
                                        caseLabels = append(caseLabels, caseLabel)
                                        n.code = append(n.code, caseStmts[2*k])
                                        if strings.TrimSpace(v) == "default" {
                                                defaultLabel = caseLabel
                                        } else {
                                                n.code = append(n.code, fmt.Sprintf("beq, %s, %s, %s", caseLabel, $1.(Node).place, v))
                                        }
                                }
                                n.code = append(n.code, fmt.Sprintf("j, %s", defaultLabel))
                                for k, v := range caseLabels {
                                        n.code = append(n.code, fmt.Sprintf("label, %s", v))
                                        n.code = append(n.code, caseStmts[2*k+1])
                                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                                }
                                n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                                return n, nil
                        } () >>
                  // TODO: Handle empty expression
//                | kwdSwitch "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch Expression \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
//                | kwdSwitch SimpleStmt terminator "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch SimpleStmt terminator \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
//                | kwdSwitch SimpleStmt terminator Expression "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch SimpleStmt terminator Expression \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
               ;

RepeatExprCaseClause : ExprCaseClause RepeatExprCaseClause
                        << func() (Attrib, error) {
                                n := Node{"", $0.(Node).code}
                                n.code = append(n.code, $1.(Node).code...)
                                n.place = fmt.Sprintf("%s, %s", $0.(Node).place, $1.(Node).place)
                                return n, nil
                        } () >>
                     | empty
                        << func() (Attrib, error) {
                                return Node{"", []string{}}, nil
                        } () >>
                     ;

// ExprCaseClause = ExprSwitchCase ":" StatementList .
// ExprSwitchCase = "case" ExpressionList | "default" .
ExprCaseClause : ExprSwitchCase ":" RepeatTerminator StatementList
                        << func() (Attrib, error) {
                                n := Node{$0.(Node).place, []string{}}
                                exprCode := ""
                                for _, v := range $0.(Node).code {
                                        exprCode += v
                                        exprCode += "\n"
                                }
                                n.code = append(n.code, exprCode)
                                stmtCode := ""
                                for _, v := range $3.(Node).code {
                                        stmtCode += v
                                        stmtCode += "\n"
                                }
                                n.code = append(n.code, stmtCode)
                                return n, nil
                        } () >>
               ;

// NOTE: The grammar is modified to support only a single expression in a
// switch statement.
// ExprSwitchCase : kwdCase ExpressionList
ExprSwitchCase : kwdCase Expression
                        << func() (Attrib, error) {
                                return Node{$1.(Node).place, $1.(Node).code}, nil
                        } () >>
               | kwdDefault
                        << func() (Attrib, error) {
                                return Node{"default", []string{}}, nil
                        } () >>
               ;
//
// // TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
// // TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
// // TypeCaseClause  = TypeSwitchCase ":" StatementList .
// // TypeSwitchCase  = "case" TypeList | "default" .
// // TypeList        = Type { "," Type } .
// TypeSwitchStmt : kwdSwitch TypeSwitchGuard "{" RepeatTerminator RepeatTypeCaseClause "}"
//                       << func() (Attrib, error) {
//                             fmt.Println("kwdSwitch TypeSwitchGuard \"{\" RepeatTerminator RepeatTypeCaseClause \"}\"");
//                             return nil, nil
//                       } () >>
//                | kwdSwitch SimpleStmt terminator TypeSwitchGuard "{" RepeatTerminator RepeatTypeCaseClause "}"
//                      << func() (Attrib, error) {
//                            fmt.Println("kwdSwitch SimpleStmt terminator TypeSwitchGuard \"{\" RepeatTerminator RepeatTypeCaseClause \"}\"");
//                            return nil, nil
//                      } () >>
//                ;
//
// RepeatTypeCaseClause : TypeCaseClause RepeatTypeCaseClause
//                     << func() (Attrib, error) {
//                           fmt.Println("TypeCaseClause RepeatTypeCaseClause");
//                           return nil, nil
//                     } () >>
//                      | empty
//                      << func() (Attrib, error) {
//                            fmt.Println("empty");
//                            return nil, nil
//                      } () >>
//                      ;
//
// TypeSwitchGuard : PrimaryExpr "." "(" kwdType ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr \".\" \"(\" kwdType \")\"");
//                       return nil, nil
//                 } () >>
//                 | identifier shortAssign PrimaryExpr "." "(" kwdType ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("identifier shortAssign PrimaryExpr \".\" \"(\" kwdType \")\"");
//                       return nil, nil
//                 } () >>
//                 ;
//
// TypeCaseClause : TypeSwitchCase ":" StatementList
//                 << func() (Attrib, error) {
//                       fmt.Println("TypeSwitchCase \":\" StatementList");
//                       return nil, nil
//                 } () >>
//                ;
//
// TypeSwitchCase : kwdCase TypeList
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdCase TypeList");
//                       return nil, nil
//                 } () >>
//                | kwdDefault
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdDefault");
//                       return nil, nil
//                 } () >>
//                ;
//
// TypeList : Type RepeatType
//                 << func() (Attrib, error) {
//                       fmt.Println("Type RepeatType");
//                       return nil, nil
//                 } () >>
//          ;
//
// RepeatType : "," Type RepeatType
//                 << func() (Attrib, error) {
//                       fmt.Println("\",\" Type RepeatType");
//                       return nil, nil
//                 } () >>
//            | empty
//                 << func() (Attrib, error) {
//                       fmt.Println("empty");
//                       return nil, nil
//                 } () >>
//            ;

// ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
// Condition = Expression .
ForStmt : kwdFor Block
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        startLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
                        for _, v := range $1.(Node).code {
                                v := strings.TrimSpace(v)
                                if v == "break" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                                } else if v == "continue" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                                } else {
                                        n.code = append(n.code, v)
                                }
                        }
                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
        | kwdFor Condition Block
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        startLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
                        n.code = append(n.code, $1.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, $1.(Node).place))
                        for _, v := range $2.(Node).code {
                                v := strings.TrimSpace(v)
                                if v == "break" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                                } else if v == "continue" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                                } else {
                                        n.code = append(n.code, v)
                                }
                        }
                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
        | kwdFor ForClause Block
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        startLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, $1.(Node).code[0]) // init statement
                        n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
                        n.code = append(n.code, $1.(Node).code[1]) // condition
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, $1.(Node).place))
                        for _, v := range $2.(Node).code {
                                v := strings.TrimSpace(v)
                                if v == "break" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                                } else if v == "continue" {
                                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                                } else {
                                        n.code = append(n.code, v)
                                }
                        }
                        n.code = append(n.code, $1.(Node).code[2]) // post statement
                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
//         | kwdFor RangeClause Block
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdFor RangeClause Block");
//                       return nil, nil
//                 } () >>
        ;
//
// // RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .
// RangeClause : kwdRange Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdRange Expression");
//                       return nil, nil
//                 } () >>
//             | ExpressionList "=" kwdRange Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("ExpressionList \"=\" kwdRange Expression");
//                       return nil, nil
//                 } () >>
//             | IdentifierList shortAssign kwdRange Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList shortAssign kwdRange Expression");
//                       return nil, nil
//                 } () >>
//             ;

// ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
// InitStmt = SimpleStmt .
// PostStmt = SimpleStmt .
// NOTE: The place value of ForClause contains the place value of the condition
// statement as that will be required in ForStmt to determine when to break. The
// place values of InitStmt and PostStmt will not be required.
// The code value of ForClause contains newline separated codes of InitStmt,
// Condition and PostStmt.
ForClause : terminator terminator
              << func() (Attrib, error) {
                      // When Condition is not specified, do an endless loop by
                      // initializing the place value to 1.
                      return Node{"1", []string{"", "", ""}}, nil
              } () >>
          | InitStmt terminator terminator
              << func() (Attrib, error) {
                        initStmtCode := ""
                        for _, v := range $0.(Node).code {
                                initStmtCode += v
                                initStmtCode += "\n"
                        }
                        return Node{"1", []string{initStmtCode, "", ""}}, nil
              } () >>
          | terminator Condition terminator
              << func() (Attrib, error) {
                        condCode := ""
                        for _, v := range $1.(Node).code {
                                condCode += v
                                condCode += "\n"
                        }
                        return Node{$1.(Node).place, []string{"", condCode, ""}}, nil
              } () >>
          | terminator terminator PostStmt
              << func() (Attrib, error) {
                        postStmtCode := ""
                        for _, v := range $2.(Node).code {
                                postStmtCode += v
                                postStmtCode += "\n"
                        }
                        return Node{"1", []string{"", "", postStmtCode}}, nil
              } () >>
          | InitStmt terminator Condition terminator
              << func() (Attrib, error) {
                        initStmtCode := ""
                        for _, v := range $0.(Node).code {
                                initStmtCode += v
                                initStmtCode += "\n"
                        }
                        condCode := ""
                        for _, v := range $2.(Node).code {
                                condCode += v
                                condCode += "\n"
                        }
                        return Node{$2.(Node).place, []string{initStmtCode, condCode, ""}}, nil
              } () >>
          | InitStmt terminator terminator PostStmt
              << func() (Attrib, error) {
                        initStmtCode := ""
                        for _, v := range $0.(Node).code {
                                initStmtCode += v
                                initStmtCode += "\n"
                        }
                        postStmtCode := ""
                        for _, v := range $3.(Node).code {
                                postStmtCode += v
                                postStmtCode += "\n"
                        }
                        return Node{"1", []string{initStmtCode, "", postStmtCode}}, nil
              } () >>
          | terminator Condition terminator PostStmt
              << func() (Attrib, error) {
                        condCode := ""
                        for _, v := range $1.(Node).code {
                                condCode += v
                                condCode += "\n"
                        }
                        postStmtCode := ""
                        for _, v := range $3.(Node).code {
                                postStmtCode += v
                                postStmtCode += "\n"
                        }
                        return Node{$1.(Node).place, []string{"", condCode, postStmtCode}}, nil
              } () >>
          | InitStmt terminator Condition terminator PostStmt
              << func() (Attrib, error) {
                        initStmtCode := ""
                        for _, v := range $0.(Node).code {
                                initStmtCode += v
                                initStmtCode += "\n"
                        }
                        condCode := ""
                        for _, v := range $2.(Node).code {
                                condCode += v
                                condCode += "\n"
                        }
                        postStmtCode := ""
                        for _, v := range $4.(Node).code {
                                postStmtCode += v
                                postStmtCode += "\n"
                        }
                        return Node{$2.(Node).place, []string{initStmtCode, condCode, postStmtCode}}, nil
              } () >>
          ;

InitStmt : SimpleStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
         ;

PostStmt : SimpleStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
         ;

// FIXME: Condition can only be a binary expression.
Condition : Expression
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
          ;

// DeferStmt = "defer" Expression .
// NOTE: Currently defer only handles function calls and not method calls.
DeferStmt : "defer" PrimaryExpr Arguments
                << func() (Attrib, error) {
                        // Add code corresponding to the arguments.
                        n := Node{"", $2.(Node).code}
                        argExpr := utils.SplitAndSanitize($2.(Node).place, ",")
                        for k, v := range argExpr {
                              n.code = append(n.code, fmt.Sprintf("=, %s.%d, %s", $1.(Node).place, k, v))
                        }
                        n.place = NewTmp()
                        // The code for the actual function call needs to be pushed to the defer stack.
                        deferCode := make(DeferStackItem, 0)
                        deferCode = append(deferCode, fmt.Sprintf("call, %s", $1.(Node).place))
                        deferCode = append(deferCode, fmt.Sprintf("store, %s", n.place))
                        deferStack.Push(deferCode)
                        return n, nil
                } () >>
          ;

PrintIntStmt : "printInt" Expression
                << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        n.code = append(n.code, fmt.Sprintf("printInt, %s, %s", $1.(Node).place, $1.(Node).place))
                        return n, nil
                } () >>
             ;

// ExpressionStmt : Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("Expression");
//                       return nil, nil
//                 } () >>
//                ;
IncDecStmt : Expression "++"
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, fmt.Sprintf("+, %s, %s, 1", $0.(Node).place, $0.(Node).place))
                        return n, nil
                } () >>
           | Expression "--"
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, fmt.Sprintf("-, %s, %s, 1", $0.(Node).place, $0.(Node).place))
                        return n, nil
                } () >>
           ;

Assignment : ExpressionList assignOp ExpressionList
                << func() (Attrib, error) {
                        op := string($1.(*token.Token).Lit)[0]
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        leftExpr := utils.SplitAndSanitize($0.(Node).place, ",")
                        rightExpr := utils.SplitAndSanitize($2.(Node).place, ",")
                        for k, v := range leftExpr {
                                n.code = append(n.code, fmt.Sprintf("%s, %s, %s, %s", op, v, v, rightExpr[k]))
                                _, ok := symTab[v]
                                if ok {
                                        if symTab[v][1] == "array" {
                                                arrayInfo := utils.SplitAndSanitize(symTab[v][0], ",")
                                                // arrayInfo contains the following info -
                                                //      0th index: array name
                                                //      1st index: array index
                                                n.code = append(n.code, fmt.Sprintf("into, %s, %s, %s, %s", arrayInfo[0], arrayInfo[0], arrayInfo[1], v))
                                        }
                                }
                        }
                        return n, nil
                } () >>
           // TODO : Redundant code
           | ExpressionList "=" ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        leftExpr := utils.SplitAndSanitize($0.(Node).place, ",")
                        rightExpr := utils.SplitAndSanitize($2.(Node).place, ",")
                        for k, v := range leftExpr {
                                if len(currSymTab.varSymTab[GetRealName(v)]) >= 2 && currSymTab.varSymTab[GetRealName(v)][1] == "pointer" {
                                        if len(rightExpr[k]) >= 7 && rightExpr[k][:7] == "pointer" {
                                                currSymTab.varSymTab[GetRealName(v)][3] = currSymTab.varSymTab[GetRealName(rightExpr[k][8:])][0]
                                        } else {
                                                currSymTab.varSymTab[GetRealName(v)][3] = currSymTab.varSymTab[GetRealName(rightExpr[k])][3]
                                        }
                                } else if len(rightExpr[k]) >= 5 && rightExpr[k][:5] == "deref" && len(v) >= 5 && v[:5] == "deref" {
                                        n.code = append(n.code, fmt.Sprintf("=, %s, %s", currSymTab.varSymTab[GetRealName(v[6:])][3], currSymTab.varSymTab[GetRealName(rightExpr[k][6:])][3]))
                                } else if len(rightExpr[k]) >= 5 && rightExpr[k][:5] == "deref" {
                                        n.code = append(n.code, fmt.Sprintf("=, %s, %s", currSymTab.varSymTab[GetRealName(v)][0], currSymTab.varSymTab[GetRealName(rightExpr[k][6:])][3]))
                                } else if len(v) >= 5 && v[:5] == "deref" {
                                        n.code = append(n.code, fmt.Sprintf("=, %s, %s", currSymTab.varSymTab[GetRealName(v[6:])][3], rightExpr[k]))
                                } else {
                                        n.code = append(n.code, fmt.Sprintf("=, %s, %s", v, rightExpr[k]))
                                        _, ok := symTab[v]
                                        if ok {
                                                if symTab[v][1] == "array" {
                                                        arrayInfo := utils.SplitAndSanitize(symTab[v][0], ",")
                                                        // arrayInfo[0]: array name
                                                        // arrayInfo[1]: array index
                                                        n.code = append(n.code, fmt.Sprintf("into, %s, %s, %s, %s", arrayInfo[0], arrayInfo[0], arrayInfo[1], v))
                                                }
                                        }
                                }
                        }
                        return n, nil
                } () >>
           ;

ShortVarDecl : IdentifierList shortAssign ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        // TODO: Structs do not support multiple short declarations in a
                        // single statement for now.
                        exprName := $2.(Node).place
                        if len(exprName) >= 6 && exprName[:6] == "struct" {
                                // NOTE: The following index calculations assume that
                                // struct names cannot include a ':' character.
                                colonIndex := strings.LastIndexAny(exprName, ":")
                                structLen, err := strconv.Atoi(exprName[7:colonIndex])
                                if err != nil {
                                        return nil, err
                                }
                                // TODO: Multiple struct initializations are not handled currently.
                                structName := $0.(Node).code[0]
                                // keeping structName in the symbol table with type as Struct
                                currSymTab.varSymTab[structName] = []string{structName, "struct"}
                                // The individual struct member initializers can contain
                                // expressions whose code need to be added before the
                                // members are initialized.
                                n.code = append(n.code, $2.(Node).code[2*structLen:]...)
                                // Add code for struct member initializations.
                                var varName, varVal string
                                for k, v := range $2.(Node).code[:2*structLen] {
                                        if k % 2 == 0 {
                                                // Member names are located at even locations.
                                                varName = v
                                        } else {
                                                // (Initialized) member values are located at odd locations.
                                                varVal = v
                                                renamedVar := RenameVariable(fmt.Sprintf("%s.%s", structName, varName))
                                                currSymTab.varSymTab[fmt.Sprintf("%s.%s", structName, varName)] = []string{renamedVar, "int"}
                                                // TODO: Add the struct initializations to symbol table. Also,
                                                // handle member accesses as -
                                                //      node := Node{1}
                                                //      b := node.val  // member access
                                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, varVal))
                                        }
                                }
                        } else {
                                n.code = $2.(Node).code
                                expr := utils.SplitAndSanitize($2.(Node).place, ",")
                                for k, v := range $0.(Node).code {
                                        renamedVar := RenameVariable(v)
                                        _, ok := currSymTab.varSymTab[v]
                                        if !ok {
                                                // TODO: All types are int currently.
                                                if len(expr[k]) >= 7 && expr[k][0:7] == "pointer" {
                                                    currSymTab.varSymTab[v] = []string{renamedVar, "pointer", "int", expr[k][8:]}
                                                } else if len(currSymTab.varSymTab[GetRealName(expr[k])]) >= 2 && currSymTab.varSymTab[GetRealName(expr[k])][1] == "pointer" {
                                                    currSymTab.varSymTab[v] = []string{renamedVar, "pointer", currSymTab.varSymTab[GetRealName(expr[k])][2] , currSymTab.varSymTab[GetRealName(expr[k])][3]}
                                                } else if len(expr[k]) >= 5 && expr[k][0:5] == "deref" {
                                                    currSymTab.varSymTab[v] = []string{renamedVar, "int"}
                                                } else {
                                                    currSymTab.varSymTab[v] = []string{renamedVar, "int"}
                                                }
                                        } else {
                                                return nil, errors.New(fmt.Sprintf("%s already declared", v))
                                        }
                                        if len(expr[k]) >= 5 && expr[k][:5] == "array" {
                                                // TODO: rename arrays
                                                n.code = append(n.code, fmt.Sprintf("decl, %s, %s", renamedVar, expr[k][6:]))
                                        } else if len(expr[k]) >= 5 && expr[k][0:5] == "deref" {
                                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, currSymTab.varSymTab[GetRealName(expr[k][6:])][3]))
                                        } else if len(currSymTab.varSymTab[v]) >= 2 && currSymTab.varSymTab[v][1] != "pointer" {
                                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", renamedVar, expr[k]))
                                        }
                                }
                        }
                        return n, nil
                } () >>
             ;

Label : identifier
                 << func() (Attrib, error) {
                       return Node{string($0.(*token.Token).Lit), []string{}}, nil
                 } () >>
              ;
