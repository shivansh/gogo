/* Lexical part */

// separator  : ',' | ':' ;
terminator : ';' '\n' | ';' | '\n' ;

/* Keywords */
kwdBreak    : 'b' 'r' 'e' 'a' 'k' ;
kwdCase     : 'c' 'a' 's' 'e' ;
kwdConst    : 'c' 'o' 'n' 's' 't' ;
kwdContinue : 'c' 'o' 'n' 't' 'i' 'n' 'u' 'e' ;
kwdDefault  : 'd' 'e' 'f' 'a' 'u' 'l' 't' ;
kwdElse     : 'e' 'l' 's' 'e' ;
kwdFunc     : 'f' 'u' 'n' 'c' ;
kwdFor      : 'f' 'o' 'r' ;
kwdGoto     : 'g' 'o' 't' 'o' ;
kwdIf       : 'i' 'f' ;
kwdImport   : 'i' 'm' 'p' 'o' 'r' 't' ;
kwdPackage  : 'p' 'a' 'c' 'k' 'a' 'g' 'e' ;
kwdRange    : 'r' 'a' 'n' 'g' 'e' ;
kwdRet      : 'r' 'e' 't' 'u' 'r' 'n' ;
kwdStruct   : 's' 't' 'r' 'u' 'c' 't' ;
kwdSwitch   : 's' 'w' 'i' 't' 'c' 'h' ;
kwdType     : 't' 'y' 'p' 'e' ;
kwdVar      : 'v' 'a' 'r' ;

/* Types */
type : 'b' 'o' 'o' 'l'
     | 'i' 'n' 't' | 'f' 'l' 'o' 'a' 't' '3' '2' | 'f' 'l' 'o' 'a' 't' '6' '4'
     | 'b' 'y' 't' 'e'
     | 's' 't' 'r' 'i' 'n' 'g'
     ;

/* Predeclared contants */
boolLit : 't' 'r' 'u' 'e' | 'f' 'a' 'l' 's' 'e' ;

/* Operators */
_relOp      : '=' '=' | '!' '=' | '<' | '<' '=' | '>' | '>' '=' ;
_addOp      : '+' | '-' | '|' | '^' ;
_mulOp      : '*' | '/' | '%' | '<' '<' | '>' '>' | '&' | '&' '^' ;
assignOp    : [ _addOp | _mulOp ] '=' ;
shortAssign : ':' '=' ;
// dotOp       : '.' ;

/* Whitespaces (suppressed) */
!whitespace : ' ' | '\t' | '\r' ;

/* Comments (suppressed) */
!comment      : _lineComment | _blockComment ;
_lineComment  : '/' '/' { . } '\n' ;
_blockComment : '/' '*' { . | '*' } '*' '/' ;

/* Letters and digits */
_letter        : _unicodeLetter | '_' ;
_unicodeLetter : 'a' - 'z' | 'A' - 'Z' ;
_decimalDigit  : '0' - '9' ;
_octalDigit    : '0' - '7' ;
_hexDigit      : _decimalDigit | 'a' - 'f' | 'A' - 'F' ;

/* Identifiers */
// TODO: Check this
// blankIdent : '_' ;
identifier : _letter { _letter | _decimalDigit } ;

/* Integer literals */
intLit      : _decimalLit | _octalLit | _hexLit ;
_decimalLit : '1' - '9' { _decimalDigit } ;
_octalLit   : '0' { _octalDigit } ;
_hexLit     : '0' ( 'x' | 'X' ) _hexDigit { _hexDigit } ;

/* Floating-point literals */
floatLit  : _decimals '.' [ _decimals ] [ _exponent ]
          | _decimals _exponent
          | '.' _decimals [ _exponent ]
          ;
_decimals : _decimalDigit { _decimalDigit } ;
_exponent : ( 'e' | 'E' ) [ '+' | '-' ] _decimals ;

/* String literals */
stringLit          :  _rawStrLit | _interpretedStrLit ;
_rawStrLit         : '`' { . } '`' ;
_interpretedStrLit : '"' { . | '\\' '"' | _escapeChar } '"' ;
/* Single-character escapes */
_escapeChar : '\\' 'n' | '\\' 'r' | '\\' 't' ;

/* Rune literals */
runeLit  : '\'' [ '\\' ] [ . ] '\'' ;

/* Syntax part */

<<
import(
        "fmt"
        "strings"

        "gogo/tmp/token"
)

type Node struct {
        place string
        code []string
}

var tmpIndex int = 0
var labelIndex int = 0

// NewTmp generates a unique temporary.
func NewTmp() string {
        t := fmt.Sprintf("t%d", tmpIndex)
        tmpIndex++
        return t
}

// NewLabel generates a unique label name.
func NewLabel() string {
        l := fmt.Sprintf("l%d", labelIndex)
        labelIndex++
        return l
}

>>

// NOTE: https://github.com/goccmack/gocc/issues/5998

/*
SourceFile: Expr ":=" Expr "+" Expr terminator
        << func() (Attrib, error) {
              n := Node{"", []string{}}
              n.code = append(n.code, "+")
              n.code = append(n.code, $0.(Node).place)
              n.code = append(n.code, $2.(Node).place)
              n.code = append(n.code, $4.(Node).place)
              n.code = append(n.code, "\n")
              return n, nil
        } () >>
        ;

Expr : identifier
        << func() (Attrib, error) {
               n := Node{"", []string{}}
               n.place = string($0.(*token.Token).Lit)
               return n, nil
        } () >>
     ;
*/

// SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
Start : SourceFile
        << func() (Attrib, error) {
                c := $0.(Node).code
                for _, v := range c {
                        if v != "\n" {
                                fmt.Println(v)
                        }
                }
                return nil, nil
        } () >>
      ;

// NewTerm : terminator RepeatTerminator ;
// SourceFile : PackageClause terminator RepeatTerminator RepeatImportDecl RepeatTopLevelDecl
SourceFile : RepeatTopLevelDecl
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
           ;

// RepeatImportDecl : ImportDecl terminator RepeatTerminator RepeatImportDecl
//                         << func() (Attrib, error) {
//                                 n := Node{"", []string{}}
//                                 n.code = append(n.code, $0.(Node).code...)
//                                 n.code = append(n.code, $3.(Node).code...)
//                                 n.code = append(n.code, "\n")
//                                 return nil, nil
//                         } () >>
//                  | empty
//                         << func() (Attrib, error) {
//                                 n := Node{"", []string{}}
//                                 return n, nil
//                         } () >>
//                  ;
//
// // ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
// // ImportSpec       = [ "." | PackageName ] ImportPath .
// // ImportPath       = string_lit .
// ImportDecl : kwdImport ImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdImport ImportSpec");
//                         return nil, nil
//                 } () >>
//            | kwdImport "(" RepeatImportSpec ")"
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdImport \"(\" RepeatImportSpec \")\"");
//                         return nil, nil
//                 } () >>
//            ;
//
// RepeatImportSpec : ImportSpec terminator RepeatImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("ImportSpec terminator RepeatImportSpec");
//                         return nil, nil
//                 } () >>
//                  | empty
//                 << func() (Attrib, error) {
//                         fmt.Println("empty");
//                         return nil, nil
//                 } () >>
//                 // TODO: '\n' can follow "import (", but a ';' cannot as opposed to go's grammar.
//                  | terminator RepeatImportSpec
//                 << func() (Attrib, error) {
//                         fmt.Println("terminator RepeatImportSpec");
//                         return nil, nil
//                 } () >>
//                  ;
//
// ImportSpec : ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("ImportPath");
//                         return nil, nil
//                 } () >>
//            | "." ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("\".\" ImportPath");
//                         return nil, nil
//                 } () >>
//            | PackageName ImportPath
//                 << func() (Attrib, error) {
//                         fmt.Println("PackageName ImportPath");
//                         return nil, nil
//                 } () >>
//            ;
//
// ImportPath : stringLit
//                 << func() (Attrib, error) {
//                       fmt.Println("stringLit");
//                       return nil, nil
//                 } () >>
//            ;
//
// PackageClause : kwdPackage PackageName
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdPackage PackageName");
//                         return nil, nil
//                 } () >>
//               ;
//
// PackageName : identifier
//                 << func() (Attrib, error) {
//                         fmt.Println("identifier");
//                         return nil, nil
//                 } () >>
//             ;

// TODO: MethodDecl is not supported at the moment.
// TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
RepeatTopLevelDecl : TopLevelDecl RepeatTopLevelDecl
                        << func() (Attrib, error) {
                              n := Node{"", $0.(Node).code}
                              n.code = append(n.code, $1.(Node).code...)
                              return n, nil
                        } () >>
                   | empty
                        << func() (Attrib, error) {
                              return Node{"", []string{}}, nil
                        } () >>
                   ;

TopLevelDecl : Declaration RepeatTerminator
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
             | FunctionDecl RepeatTerminator
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
             ;

// Declaration = ConstDecl | TypeDecl | VarDecl .
Declaration : ConstDecl
                    << func() (Attrib, error) {
                            return Node{"", $0.(Node).code}, nil
                    } () >>
            // | TypeDecl
            //         << func() (Attrib, error) {
            //               fmt.Println("TypeDecl");
            //               return nil, nil
            //         } () >>
            | VarDecl
                    << func() (Attrib, error) {
                            return Node{"", $0.(Node).code}, nil
                    } () >>
            ;

// VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
// VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
VarDecl : kwdVar VarSpec
            << func() (Attrib, error) {
                    return Node{"", $1.(Node).code}, nil
            } () >>
//         | kwdVar "(" RepeatTerminator RepeatVarSpec ")"
//             << func() (Attrib, error) {
//                   fmt.Println("kwdVar \"(\" RepeatTerminator RepeatVarSpec \")\"");
//                   return nil, nil
//             } () >>
        ;
//
// // VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
// RepeatVarSpec : VarSpec terminator RepeatTerminator RepeatVarSpec
//                 << func() (Attrib, error) {
//                       fmt.Println("VarSpec terminator RepeatTerminator RepeatVarSpec");
//                       return nil, nil
//                 } () >>
//               | VarSpec RepeatTerminator
//                 << func() (Attrib, error) {
//                       fmt.Println("VarSpec RepeatTerminator");
//                       return nil, nil
//                 } () >>
//               ;
//
VarSpec : IdentifierList Type
            << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        for _, v := range $0.(Node).code {
                                n.code = append(n.code, fmt.Sprintf("=, %s, 0", v))
                        }
                        return n, nil
            } () >>
        | IdentifierList Type "=" ExpressionList
            << func() (Attrib, error) {
                        n := Node{"", $3.(Node).code}
                        expr := strings.Split($3.(Node).place, ",")
                        for k, v := range $0.(Node).code {
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", v, expr[k]))

                        }
                        return n, nil
            } () >>
        | IdentifierList "=" ExpressionList
            << func() (Attrib, error) {
                n := Node{"", $2.(Node).code}
                expr := strings.Split($2.(Node).place, ",")
                for k, v := range $0.(Node).code {
                        n.code = append(n.code, fmt.Sprintf("=, %s, %s", v, expr[k]))

                }
                return n, nil
            } () >>
        | empty
            << func() (Attrib, error) {
                    return Node{"", []string{}}, nil
            } () >>
        ;

// TypeDecl  = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
// TypeSpec  = AliasDecl | TypeDef .
// AliasDecl = identifier "=" Type
// TypeDef   = identifier Type
// TypeDecl : kwdType TypeSpec
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdType TypeSpec");
//                       return nil, nil
//                 } () >>
//          | kwdType "(" RepeatTerminator RepeatTypeSpec ")"
//                 << func() (Attrib, error) {
//                         fmt.Println("kwdType \"(\" RepeatTerminator RepeatTypeSpec \")\"");
//                         return nil, nil
//                 } () >>
//          ;
//
// RepeatTypeSpec : TypeSpec terminator RepeatTerminator RepeatTypeSpec
//                     << func() (Attrib, error) {
//                             fmt.Println("TypeSpec terminator RepeatTerminator RepeatTypeSpec");
//                             return nil, nil
//                     } () >>
//                | TypeSpec RepeatTerminator
//                     << func() (Attrib, error) {
//                             fmt.Println("TypeSpec RepeatTerminator");
//                             return nil, nil
//                     } () >>
//                ;
//
// TypeSpec : AliasDecl
//             << func() (Attrib, error) {
//                     fmt.Println("AliasDecl");
//                     return nil, nil
//             } () >>
//          | TypeDef
//             << func() (Attrib, error) {
//                     fmt.Println("TypeDef");
//                     return nil, nil
//             } () >>
//          | empty
//             << func() (Attrib, error) {
//                     fmt.Println("empty");
//                     return nil, nil
//             } () >>
//          ;
//
// AliasDecl : identifier "=" Type
//             << func() (Attrib, error) {
//                     fmt.Println("identifier \"=\" Type");
//                     return nil, nil
//             } () >>
//           ;
//
// TypeDef : identifier Type
//             << func() (Attrib, error) {
//                     fmt.Println("identifier Type");
//                     return nil, nil
//             } () >>
//         ;

// ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
// ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .
// IdentifierList = identifier { "," identifier } .
// ExpressionList = Expression { "," Expression } .
ConstDecl : kwdConst ConstSpec
            << func() (Attrib, error) {
                    return Node{"", $1.(Node).code}, nil
            } () >>
          // | kwdConst "(" RepeatTerminator RepeatConstSpec ")"
          //   << func() (Attrib, error) {
          //           fmt.Println("kwdConst \"(\" RepeatTerminator RepeatConstSpec \")\"");
          //           return nil, nil
          //   } () >>
          ;

// RepeatConstSpec : ConstSpec terminator RepeatTerminator RepeatConstSpec
//                 << func() (Attrib, error) {
//                       fmt.Println("ConstSpec terminator RepeatTerminator RepeatConstSpec");
//                       return nil, nil
//                 } () >>
//                 | ConstSpec RepeatTerminator
//                 << func() (Attrib, error) {
//                       fmt.Println("ConstSpec RepeatTerminator");
//                       return nil, nil
//                 } () >>
//                 ;

ConstSpec : IdentifierList
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        for _, v := range $0.(Node).code {
                                n.code = append(n.code, fmt.Sprintf("=, %s, 0", v))
                        }
                        return n, nil
                } () >>
          | IdentifierList "=" ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", $2.(Node).code}
                        expr := strings.Split($2.(Node).place, ",")
                        for k, v := range $0.(Node).code {
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", v, expr[k]))

                        }
                        return n, nil
                } () >>
          // | IdentifierList Type "=" ExpressionList
          //       << func() (Attrib, error) {
          //               fmt.Println("IdentifierList Type \"=\" ExpressionList");
          //               return nil, nil
          //       } () >>
          // | empty
          //       << func() (Attrib, error) {
          //               fmt.Println("empty");
          //               return nil, nil
          //       } () >>
          ;

ExpressionList : Expression
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
               | Expression "," ExpressionList
               << func() (Attrib, error) {
                       n := Node{"", $0.(Node).code}
                       n.code = append(n.code, $2.(Node).code...)
                       n.place = fmt.Sprintf("%s,%s", $0.(Node).place, $2.(Node).place)
                       return n, nil
               } () >>
               ;

// Expression = UnaryExpr | Expression binary_op Expression .
Expression : Expression BinaryOp Expression
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        op := $1.(Node).place
                        if op == "==" || op == "!=" || op == "<=" || op == "<" || op == ">=" || op == ">" {
                                branchOp := ""
                                n.place = NewTmp()
                                falseLabel := NewLabel()
                                afterLabel := NewLabel()
                                switch op {
                                        case "==":
                                                branchOp = "bne"
                                        case "!=":
                                                branchOp = "beq"
                                        case "<=":
                                                branchOp = "bgt"
                                        case "<":
                                                branchOp = "bge"
                                        case ">=":
                                                branchOp = "blt"
                                        case ">":
                                                branchOp = "ble"
                                }
                                n.code = append(n.code, fmt.Sprintf("%s, %s, %s, %s", branchOp, falseLabel, $0.(Node).place, $2.(Node).place))
                                n.code = append(n.code, fmt.Sprintf("=, %s, 1", n.place))
                                n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                                n.code = append(n.code, fmt.Sprintf("label, %s", falseLabel))
                                n.code = append(n.code, fmt.Sprintf("=, %s, 0", n.place))
                                n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        } else if op == "+" || op == "-" || op == "*" || op == "/" {
                                n.place = NewTmp()
                                n.code = append(n.code, fmt.Sprintf("%s, %s, %s, %s", op, n.place, $0.(Node).place, $2.(Node).place))
                                n.code = append(n.code, "\n")
                        }
                        switch $1.(Node).place {
                        }
                        return n, nil
              } () >>
           | UnaryExpr
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, $0.(Node).code}, nil
                } () >>
//           // Since PointerType defines "*" to be a token, expressions
//           // like `y = x * 2` will not be parsed because parser will
//           // expect a "BinaryOp" token but the parser will return a
//           // "*" token. To avoid such ambiguity the following (extra)
//           // rule is introduced.
//           | Expression "*" Expression
//                 << func() (Attrib, error) {
//                         fmt.Println("Expression \"*\" Expression");
//                         return nil, nil
//                 } () >>
           ;

BinaryOp    : "||"
                  << func() (Attrib, error) {
                        fmt.Println("\"||\"");
                        return nil, nil
                  } () >>

              | "&&"
                  << func() (Attrib, error) {
                    fmt.Println("\"&&\"");
                    return nil, nil
                  } () >>
              | RelOp
                  << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                  } () >>
              | AddOp
                  << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                  } () >>
              // | MulOp
              //     << func() (Attrib, error) {
              //           return Node{$0.(Node).place, []string{}}, nil
              //     } () >>
              ;

// unaryOp will be used for defining UnaryExpr in parser.
// unaryOp     : '+' | '-' | '!' | '^' | '*' | '&' | '<' '-' ;
// binaryOp    : '|' '|' | '&' '&' | _relOp | _addOp | _mulOp ;
RelOp : "=="
       << func() (Attrib, error) {
             return Node{"==", []string{}}, nil
       } () >>
      | "!="
      << func() (Attrib, error) {
            return Node{"!=", []string{}}, nil
      } () >>
      | "<="
      << func() (Attrib, error) {
            return Node{"<=", []string{}}, nil
      } () >>
      | "<"
      << func() (Attrib, error) {
              return Node{"<", []string{}}, nil
      } () >>
      | ">="
      << func() (Attrib, error) {
            return Node{">=", []string{}}, nil
      } () >>
      | ">"
      << func() (Attrib, error) {
            return Node{">", []string{}}, nil
      } () >>
      ;

AddOp : "+"
       << func() (Attrib, error) {
              return Node{"+", []string{}}, nil
       } () >>
      | "-"
      << func() (Attrib, error) {
            return Node{"-", []string{}}, nil
      } () >>
//       | "|"
//       << func() (Attrib, error) {
//             fmt.Println("\"|\"");
//             return nil, nil
//       } () >>
//       | "^"
//       << func() (Attrib, error) {
//             fmt.Println("\"^\"");
//             return nil, nil
//       } () >>
      ;
//
// MulOp : "*"
//       << func() (Attrib, error) {
//             fmt.Println("\"*\"");
//             return nil, nil
//       } () >>
//       | "/"
//       << func() (Attrib, error) {
//             fmt.Println("\"/\"");
//             return nil, nil
//       } () >>
//       | "%"
//       << func() (Attrib, error) {
//             fmt.Println("\"%\"");
//             return nil, nil
//       } () >>
//       | "<<"
//       << func() (Attrib, error) {
//             fmt.Println("\"<<\"");
//             return nil, nil
//       } () >>
//       | ">>"
//       << func() (Attrib, error) {
//             fmt.Println("\"<<\""); // TODO: Fix this
//             return nil, nil
//       } () >>
//       | "&"
//       << func() (Attrib, error) {
//             fmt.Println("\"&\"");
//             return nil, nil
//       } () >>
//       | "&^"
//             fmt.Println("\"&^\"");
//             return nil, nil
//       } () >>
//       ;
//
// // UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .
UnaryExpr : PrimaryExpr
          << func() (Attrib, error) {
                return Node{$0.(Node).place, $0.(Node).code}, nil
          } () >>
//           | UnaryOp UnaryExpr
//           << func() (Attrib, error) {
//                 fmt.Println("UnaryOp UnaryExpr");
//                 return nil, nil
//           } () >>
//           | "*" UnaryExpr
//           << func() (Attrib, error) {
//                 fmt.Println("\"*\" UnaryExpr");
//                 return nil, nil
//           } () >>
          ;
//
// UnaryOp : "+"
//               << func() (Attrib, error) {
//                     fmt.Println("\"+\"");
//                     return nil, nil
//               } () >>
//         | "-"
//               << func() (Attrib, error) {
//                     fmt.Println("\"-\"");
//                     return nil, nil
//               } () >>
//         | "!"
//               << func() (Attrib, error) {
//                     fmt.Println("\"!\"");
//                     return nil, nil
//               } () >>
//         | "^"
//               << func() (Attrib, error) {
//                     fmt.Println("\"^\"");
//                     return nil, nil
//               } () >>
//         | "*"
//               << func() (Attrib, error) {
//                     fmt.Println("\"*\"");
//                     return nil, nil
//               } () >>
//         | "&"
//               << func() (Attrib, error) {
//                     fmt.Println("\"&\"");
//                     return nil, nil
//               } () >>
//         | "<-"
//               << func() (Attrib, error) {
//                     fmt.Println("\"<-\"");
//                     return nil, nil
//               } () >>
//         ;
//
// // PrimaryExpr =
// //  Operand |
// //  Conversion |
// //  MethodExpr |
// //  PrimaryExpr Selector |
// //  PrimaryExpr Index |
// //  PrimaryExpr Slice |
// //  PrimaryExpr TypeAssertion |
// //  PrimaryExpr Arguments .
PrimaryExpr : Operand
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                } () >>
//             | Conversion
//                 << func() (Attrib, error) {
//                       fmt.Println("Conversion");
//                       return nil, nil
//                 } () >>
//             | PrimaryExpr Selector
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr Selector");
//                       return nil, nil
//                 } () >>
//             | PrimaryExpr Index
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr Index");
//                       return nil, nil
//                 } () >>
//             | PrimaryExpr Slice
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr Slice");
//                       return nil, nil
//                 } () >>
//             | PrimaryExpr TypeAssertion
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr TypeAssertion");
//                       return nil, nil
//                 } () >>
            | PrimaryExpr Arguments
                // This is the production rule for a function call.
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        n.place = NewTmp()
                        n.code = append(n.code, fmt.Sprintf("call, %s", $0.(Node).place))
                        n.code = append(n.code, fmt.Sprintf("store, %s", n.place))
                        n.code = append(n.code, "\n")
                        return n, nil
                } () >>
            ;
//
// // Operand     = Literal | OperandName | "(" Expression ")" .
// // Literal     = BasicLit | CompositeLit | FunctionLit .
// // BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
// // OperandName = identifier | QualifiedIdent.
Operand : Literal
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                } () >>
        | OperandName
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                } () >>
//         | "(" Expression ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Expression \")\"");
//                       return nil, nil
//                 } () >>
        ;
//
Literal : BasicLit
                << func() (Attrib, error) {
                        return Node{$0.(Node).place, []string{}}, nil
                } () >>
//         | CompositeLit
//                 << func() (Attrib, error) {
//                       fmt.Println("CompositeLit");
//                       return nil, nil
//                 } () >>
//         | FunctionLit
//                 << func() (Attrib, error) {
//                       fmt.Println("FunctionLit");
//                       return nil, nil
//                 } () >>
        ;
//
BasicLit : intLit
                << func() (Attrib, error) {
                        return Node{string($0.(*token.Token).Lit), []string{}}, nil
                } () >>
//          | floatLit
//                 << func() (Attrib, error) {
//                       fmt.Println("floatLit");
//                       return nil, nil
//                 } () >>
//          | runeLit
//                 << func() (Attrib, error) {
//                       fmt.Println("runeLit");
//                       return nil, nil
//                 } () >>
//          | stringLit
//                 << func() (Attrib, error) {
//                       fmt.Println("stringLit");
//                       return nil, nil
//                 } () >>
//          | boolLit
//                << func() (Attrib, error) {
//                      fmt.Println("boolLit");
//                      return nil, nil
//                } () >>
         ;
//
// // CompositeLit  = LiteralType LiteralValue .
// // LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
// //                 SliceType | MapType | TypeName .
// // LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
// // ElementList   = KeyedElement { "," KeyedElement } .
// // KeyedElement  = [ Key ":" ] Element .
// // Key           = FieldName | Expression | LiteralValue .
// // FieldName     = identifier .
// // Element       = Expression | LiteralValue .
// CompositeLit : LiteralType LiteralValue
//                     << func() (Attrib, error) {
//                           fmt.Println("LiteralType LiteralValue");
//                           return nil, nil
//                     } () >>
//              ;
//
// LiteralType : StructType
//                     << func() (Attrib, error) {
//                           fmt.Println("StructType");
//                           return nil, nil
//                     } () >>
//             | ArrayType
//                     << func() (Attrib, error) {
//                           fmt.Println("ArrayType");
//                           return nil, nil
//                     } () >>
//             | "[" "..." "]" ElementType
//                     << func() (Attrib, error) {
//                           fmt.Println("\"[\" \"...\" \"]\" ElementType");
//                           return nil, nil
//                     } () >>
//
//             | SliceType
//                   << func() (Attrib, error) {
//                         fmt.Println("SliceType");
//                         return nil, nil
//                   } () >>
//             | type
//                   << func() (Attrib, error) {
//                         fmt.Println("type");
//                         return nil, nil
//                   } () >>
//             ;
//
// LiteralValue : "{" RepeatTerminator "}"
//                     << func() (Attrib, error) {
//                           fmt.Println("RepeatTerminator");
//                           return nil, nil
//                     } () >>
//              // NOTE: We don't support adding a ',' after the last KeyedElement
//              // as opposed to the official go language.
//              | "{" RepeatTerminator ElementList "}"
//                    << func() (Attrib, error) {
//                          fmt.Println("\"{\" RepeatTerminator ElementList \"}\" ");
//                          return nil, nil
//                    } () >>
//              ;
//
// ElementList : KeyedElement RepeatKeyedElement
//                 << func() (Attrib, error) {
//                       fmt.Println("KeyedElement RepeatKeyedElement");
//                       return nil, nil
//                 } () >>
//             ;
//
// RepeatKeyedElement : "," RepeatTerminator KeyedElement RepeatKeyedElement
//                         << func() (Attrib, error) {
//                               fmt.Println("\",\" RepeatTerminator KeyedElement RepeatKeyedElement");
//                               return nil, nil
//                         } () >>
//                    | RepeatTerminator
//                         << func() (Attrib, error) {
//                               fmt.Println("\",\" RepeatTerminator");
//                               return nil, nil
//                         } () >>
//                    // | "," RepeatTerminator
//                    //      << func() (Attrib, error) {
//                    //            fmt.Println("\",\" RepeatTerminator");
//                    //            return nil, nil
//                    //      } () >>
//                    // | empty
//                    //      << func() (Attrib, error) {
//                    //            fmt.Println("empty");
//                    //            return nil, nil
//                    //      } () >>
//                    ;
//
// KeyedElement : Element
//                 << func() (Attrib, error) {
//                         fmt.Println("Element");
//                         return nil, nil
//                 } () >>
//              | Key ":" Element
//                 << func() (Attrib, error) {
//                         fmt.Println("Key \":\" Element");
//                         return nil, nil
//                 } () >>
//              ;
//
// Key : FieldName
//         << func() (Attrib, error) {
//               fmt.Println("FieldName");
//               return nil, nil
//         } () >>
//     | Expression
//         << func() (Attrib, error) {
//               fmt.Println("Expression");
//               return nil, nil
//         } () >>
//     | LiteralValue
//         << func() (Attrib, error) {
//               fmt.Println("LiteralValue");
//               return nil, nil
//         } () >>
//     ;
//
// FieldName : identifier
//                 << func() (Attrib, error) {
//                       fmt.Println("identifier");
//                       return nil, nil
//                 } () >>
//           ;
//
// Element : Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("Expression");
//                       return nil, nil
//                 } () >>
//         | LiteralValue
//                 << func() (Attrib, error) {
//                       fmt.Println("LiteralValue");
//                       return nil, nil
//                 } () >>
//         ;
//
// // FunctionLit = "func" Signature FunctionBody .
// FunctionLit : kwdFunc Signature FunctionBody
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdFunc Signature FunctionBody");
//                       return nil, nil
//                 } () >>
//             ;

OperandName : identifier
                << func() (Attrib, error) {
                        n := Node{string($0.(*token.Token).Lit), []string{}}
                        return n, nil
                } () >>
            ;

// // Selector       = "." identifier .
// // Index          = "[" Expression "]" .
// // Slice          = "[" [ Expression ] ":" [ Expression ] "]" |
// //                  "[" [ Expression ] ":" Expression ":" Expression "]" .
// // TypeAssertion  = "." "(" Type ")" .
// // Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
// // Conversion = Type "(" Expression [ "," ] ")"
// Selector : "." identifier
//               << func() (Attrib, error) {
//                     fmt.Println("\".\" identifier");
//                     return nil, nil
//               } () >>
//          ;
//
// Index : "[" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       ;
//
// Slice : "[" ":" "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" \":\" \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" Expression ":" "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \":\" \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" Expression ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" ":" Expression ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" \":\" Expression \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       | "[" Expression ":" Expression ":" Expression "]"
//               << func() (Attrib, error) {
//                     fmt.Println("\"[\" Expression \":\" Expression \":\" Expression \"]\"");
//                     return nil, nil
//               } () >>
//       ;
//
// TypeAssertion : "." "(" Type ")"
//               << func() (Attrib, error) {
//                     fmt.Println("\".\" \"(\" Type \")\"");
//                     return nil, nil
//               } () >>
//               ;

// Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
// NOTE: Since compilation of local variables has not yet been done, only empty
// arguments are supported for the time being.
Arguments : "(" ")"
//           | "(" ExpressionList ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" ExpressionList "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" ExpressionList "..." ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \"...\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" ExpressionList "..." "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ExpressionList \"...\" \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "..." ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \"...\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "..." "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \"...\" \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \",\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList "..." ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \"...\" \")\"");
//                       return nil, nil
//                 } () >>
//           | "(" Type "," ExpressionList "..." "," ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" Type \",\" ExpressionList \"...\" \",\" \")\"");
//                       return nil, nil
//                 } () >>
          ;
//
// Conversion : Type "(" Expression ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("Type \"(\" Expression \")\"");
//                       return nil, nil
//                 } () >>
//            | Type "(" Expression "," ")"
//                << func() (Attrib, error) {
//                      fmt.Println("Type \"(\" Expression \",\" \")\"");
//                      return nil, nil
//                } () >>
//            ;
//
// // FunctionDecl = "func" FunctionName Signature [ FunctionBody ] .
// // FunctionName = identifier .
// // FunctionBody = Block .
FunctionDecl : kwdFunc FunctionName Signature FunctionBody
                << func() (Attrib, error) {
                        n := Node{"", []string{fmt.Sprintf("func, %s", $1.(Node).place)}}
                        n.code = append(n.code, $3.(Node).code...)
                        return n, nil
                } () >>
             | kwdFunc FunctionName Signature
             ;

// // Signature      = Parameters [ Result ] .
// // Result         = Parameters | Type .
// // Parameters     = "(" [ ParameterList [ "," ] ] ")" .
// // ParameterList  = ParameterDecl { "," ParameterDecl } .
// // ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
Signature : Parameters
//           | Parameters Result
//                 << func() (Attrib, error) {
//                       fmt.Println("Parameters Result");
//                       return nil, nil
//                 } () >>
          ;
//
// Result : Parameters
//               << func() (Attrib, error) {
//                     fmt.Println("Parameters");
//                     return nil, nil
//               } () >>
//        | Type
//               << func() (Attrib, error) {
//                     fmt.Println("Type");
//                     return nil, nil
//               } () >>
//        ;
//
// // TODO: Ignore terminator
// // TODO: Parameters cannot end in ','
Parameters : "(" RepeatTerminator ")"
//            | "(" ParameterList ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("\"(\" ParameterList \")\"");
//                       return nil, nil
//                 } () >>
           ;
//
// ParameterList : ParameterDecl RepeatParameterDecl
//                 << func() (Attrib, error) {
//                       fmt.Println("ParameterDecl RepeatParameterDecl");
//                       return nil, nil
//                 } () >>
//               ;
//
// RepeatParameterDecl : "," ParameterDecl RepeatParameterDecl
//                         << func() (Attrib, error) {
//                               fmt.Println("\",\" ParameterDecl RepeatParameterDecl");
//                               return nil, nil
//                         } () >>
//                         | empty
//                         << func() (Attrib, error) {
//                               fmt.Println("empty");
//                               return nil, nil
//                         } () >>
//                     ;
//
// ParameterDecl : IdentifierList Type
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList Type");
//                       return nil, nil
//                 } () >>
//                 | Type
//                 << func() (Attrib, error) {
//                       fmt.Println("Type");
//                       return nil, nil
//                 } () >>
//                 | "..." Type
//                 << func() (Attrib, error) {
//                       fmt.Println("\"...\" Type");
//                       return nil, nil
//                 } () >>
//                 | IdentifierList "..." Type
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList \"...\" Type");
//                       return nil, nil
//                 } () >>
//               ;
//
// // Type      = TypeName | TypeLit | "(" Type ")" .
// // TypeName  = identifier | QualifiedIdent .
// // TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
// //             SliceType | MapType | ChannelType .
Type : type
        << func() (Attrib, error) {
              return nil, nil
        } () >>
//       | identifier
//         << func() (Attrib, error) {
//                 fmt.Println("identifier");
//                 return nil, nil
//         } () >>
//       | TypeLit
//         << func() (Attrib, error) {
//               fmt.Println("TypeLit");
//               return nil, nil
//         } () >>
//       | "(" Type ")"
//         << func() (Attrib, error) {
//               fmt.Println("\"(\" Type \")\"");
//               return nil, nil
//         } () >>
     ;
//
// TypeLit : ArrayType
//         << func() (Attrib, error) {
//               fmt.Println("ArrayType");
//               return nil, nil
//         } () >>
//         | StructType
//         << func() (Attrib, error) {
//               fmt.Println("StructType");
//               return nil, nil
//         } () >>
//         | PointerType
//         << func() (Attrib, error) {
//               fmt.Println("PointerType");
//               return nil, nil
//         } () >>
//         | FunctionType
//         << func() (Attrib, error) {
//               fmt.Println("FunctionType");
//               return nil, nil
//         } () >>
//         | SliceType
//         << func() (Attrib, error) {
//               fmt.Println("SliceType");
//               return nil, nil
//         } () >>
//         ;
//
// // ArrayType   = "[" ArrayLength "]" ElementType .
// // ArrayLength = Expression .
// // ElementType = Type .
// ArrayType : "[" ArrayLength "]" ElementType
//             << func() (Attrib, error) {
//                   fmt.Println("\"[\" ArrayLength \"]\" ElementType");
//                   return nil, nil
//             } () >>
//             ;
//
// ArrayLength : Expression
//             << func() (Attrib, error) {
//                   fmt.Println("Expression");
//                   return nil, nil
//             } () >>
//             ;
//
// ElementType : Type
//             << func() (Attrib, error) {
//                   fmt.Println("Type");
//                   return nil, nil
//             } () >>
//             ;
//
// // StructType    = kwdStruct "{" { FieldDecl ";" } "}" .
// // FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
// // EmbeddedField = [ "*" ] TypeName .
// // Tag           = string_lit .
// StructType : kwdStruct RepeatTerminator "{" RepeatTerminator RepeatFieldDecl "}"
//             << func() (Attrib, error) {
//                   fmt.Println("kwdStruct RepeatTerminator \"{\" RepeatTerminator RepeatFieldDecl \"}\"");
//                   return nil, nil
//             } () >>
//            ;
//
// RepeatFieldDecl : FieldDecl terminator RepeatTerminator RepeatFieldDecl
//                 << func() (Attrib, error) {
//                       fmt.Println("FieldDecl terminator RepeatTerminator RepeatFieldDecl");
//                       return nil, nil
//                 } () >>
//                 | FieldDecl RepeatTerminator
//                 << func() (Attrib, error) {
//                       fmt.Println("FieldDecl RepeatTerminator");
//                       return nil, nil
//                 } () >>
//                 ;
//
// FieldDecl : IdentifierList Type
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList Type");
//                       return nil, nil
//                 } () >>
//           | IdentifierList Type Tag
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList Type Tag");
//                       return nil, nil
//                 } () >>
//           | EmbeddedField
//                 << func() (Attrib, error) {
//                       fmt.Println("EmbeddedField");
//                       return nil, nil
//                 } () >>
//           | EmbeddedField Tag
//                 << func() (Attrib, error) {
//                       fmt.Println("EmbeddedField Tag");
//                       return nil, nil
//                 } () >>
//           | empty
//                 << func() (Attrib, error) {
//                       fmt.Println("empty");
//                       return nil, nil
//                 } () >>
//           ;
//
// EmbeddedField : type
//                 << func() (Attrib, error) {
//                       fmt.Println("type");
//                       return nil, nil
//                 } () >>
//               | "*" type
//                 << func() (Attrib, error) {
//                       fmt.Println("\"*\" type");
//                       return nil, nil
//                 } () >>
//               ;
//
// Tag : stringLit
//         << func() (Attrib, error) {
//               fmt.Println("stringLit");
//               return nil, nil
//         } () >>
//     ;
//
// // PointerType = "*" BaseType .
// // BaseType    = Type .
// PointerType : "*" BaseType
//                 << func() (Attrib, error) {
//                       fmt.Println("\"*\" BaseType");
//                       return nil, nil
//                 } () >>
//             ;
//
// BaseType : Type
//                 << func() (Attrib, error) {
//                       fmt.Println("Type");
//                       return nil, nil
//                 } () >>
//          ;
//
// // FunctionType   = "func" Signature .
// // Signature      = Parameters [ Result ] .
// // Result         = Parameters | Type .
// // Parameters     = "(" [ ParameterList [ "," ] ] ")" .
// // ParameterList  = ParameterDecl { "," ParameterDecl } .
// // ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
// FunctionType : kwdFunc Signature
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdFunc Signature");
//                       return nil, nil
//                 } () >>
//              ;
//
// // SliceType = "[" "]" ElementType .
// SliceType : "[" "]" ElementType
//                 << func() (Attrib, error) {
//                       fmt.Println("\"[\" \"]\" ElementType");
//                       return nil, nil
//                 } () >>
//           ;
//
// // TODO
// // IdentifierList = identifier { "," identifier } .
IdentifierList : identifier
                        << func() (Attrib, error) {
                                return Node{"", []string{string($0.(*token.Token).Lit)}}, nil
                        } () >>
               | identifier "," IdentifierList
                        << func() (Attrib, error) {
                                n := Node{"", []string{string($0.(*token.Token).Lit)}}
                                n.code = append(n.code, $2.(Node).code...)
                                return n, nil
                        } () >>
               ;
//
FunctionName : identifier
                << func() (Attrib, error) {
                        return Node{string($0.(*token.Token).Lit), []string{}}, nil
                 } () >>
              ;

FunctionBody : Block
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
             ;

RepeatTerminator : terminator RepeatTerminator
                << func() (Attrib, error) {
                      return nil, nil
                } () >>
                 | empty
                << func() (Attrib, error) {
                      return nil, nil
                } () >>
                 ;

StatementList : Statement terminator RepeatTerminator StatementList
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $3.(Node).code...)
                        return n, nil
                } () >>
              | Statement RepeatTerminator
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
              ;
//
// // Statement = Declaration | LabeledStmt | SimpleStmt |
// //             GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
// //             FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
// //             DeferStmt .
Statement : Declaration
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
//           | LabeledStmt
//                 << func() (Attrib, error) {
//                       fmt.Println("LabeledStmt");
//                       return nil, nil
//                 } () >>
          | SimpleStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
          | ReturnStmt
                << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                } () >>
//           | BreakStmt
//                 << func() (Attrib, error) {
//                       fmt.Println("BreakStmt");
//                       return nil, nil
//                 } () >>
//          | ContinueStmt
//                << func() (Attrib, error) {
//                      fmt.Println("ContinueStmt");
//                      return nil, nil
//                } () >>
//          | GotoStmt
//                 << func() (Attrib, error) {
//                       fmt.Println("GotoStmt");
//                       return nil, nil
//                 } () >>
//          // TODO: FallthroughStmt is not supported currently.
//          | Block
//                 << func() (Attrib, error) {
//                       fmt.Println("Block");
//                       return nil, nil
//                 } () >>
         | IfStmt
               << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
               } () >>
//          | SwitchStmt
//                 << func() (Attrib, error) {
//                       fmt.Println("SwitchStmt");
//                       return nil, nil
//                 } () >>
         | ForStmt
                << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
                } () >>
          ;
//
// // LabeledStmt = Label ":" Statement .
// // Label       = identifier .
// LabeledStmt : Label ":" RepeatTerminator Statement
//                 << func() (Attrib, error) {
//                       fmt.Println("Label \":\" RepeatTerminator Statement");
//                       return nil, nil
//                 } () >>
//             ;
//
// // SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
// // EmptyStmt = .
// // ExpressionStmt = Expression .
// // IncDecStmt = Expression ( "++" | "--" ) .
// // Assignment = ExpressionList assign_op ExpressionList .
// // assign_op = [ add_op | mul_op ] "=" .
// // ShortVarDecl = IdentifierList ":=" ExpressionList .

SimpleStmt : EmptyStmt
                << func() (Attrib, error) {
                        return Node{"", []string{}}, nil
                } () >>
           | Assignment
               << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
               } () >>
           | ShortVarDecl
               << func() (Attrib, error) {
                       return Node{"", $0.(Node).code}, nil
               } () >>
           | IncDecStmt
                 << func() (Attrib, error) {
                        return Node{"", $0.(Node).code}, nil
                 } () >>
           ;

// SimpleStmt : ExpressionStmt
//                 << func() (Attrib, error) {
//                       fmt.Println("ExpressionStmt");
//                       return nil, nil
//                 } () >>
//            | Assignment
//                << func() (Attrib, error) {
//                      fmt.Println("Assignment");
//                      return nil, nil
//                } () >>
//            | ShortVarDecl
//                << func() (Attrib, error) {
//                      fmt.Println("ShortVarDecl");
//                      return nil, nil
//                } () >>
//            | EmptyStmt
//                << func() (Attrib, error) {
//                      fmt.Println("EmptyStmt");
//                      return nil, nil
//                } () >>
//            ;

EmptyStmt : empty ;

ReturnStmt : kwdRet
                << func() (Attrib, error) {
                        return Node{"", []string{"ret,"}}, nil
                } () >>
           | kwdRet ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        n.code = append(n.code, $1.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("ret, %s", $1.(Node).place))
                        return n, nil
                } () >>
           ;

// // BreakStmt = "break" [ Label ] .
// BreakStmt : kwdBreak
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdBreak");
//                       return nil, nil
//                 } () >>
//           | kwdBreak Label
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdBreak Label");
//                       return nil, nil
//                 } () >>
//           ;
//
// // ContinueStmt = "continue" [ Label ] .
// ContinueStmt : kwdContinue
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdContinue");
//                       return nil, nil
//                 } () >>
//              | kwdContinue Label
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdContinue Label");
//                       return nil, nil
//                 } () >>
//               ;
//
// // GotoStmt = "goto" Label .
// GotoStmt : kwdGoto Label
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdGoto Label");
//                       return nil, nil
//                 } () >>
//          ;
//
Block : "{" RepeatTerminator StatementList "}"
                << func() (Attrib, error) {
                        return Node{"", $2.(Node).code}, nil
                } () >>
      ;

// IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .
IfStmt : kwdIf Expression Block
              << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, $1.(Node).place))
                        n.code = append(n.code, $2.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        n.code = append(n.code, "\n")
                        return n, nil
              } () >>
       | kwdIf Expression Block kwdElse Block
                << func() (Attrib, error) {
                        n := Node{"", $1.(Node).code}
                        elseLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", elseLabel, $1.(Node).place))
                        n.code = append(n.code, $2.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", afterLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", elseLabel))
                        n.code = append(n.code, $4.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                      fmt.Println("kwdIf Expression Block kwdElse Block");
                      return nil, nil
                } () >>
       // | kwdIf Expression Block kwdElse IfStmt
       //          << func() (Attrib, error) {
       //               fmt.Println("kwdIf SimpleStmt terminator Expression Block");
       //               return nil, nil
       //          } () >>
//        | kwdIf SimpleStmt terminator Expression Block
//                << func() (Attrib, error) {
//                      fmt.Println("kwdIf SimpleStmt terminator Expression Block");
//                      return nil, nil
//                } () >>
//        | kwdIf SimpleStmt terminator Expression Block kwdElse IfStmt
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdIf SimpleStmt terminator Expression Block kwdElse IfStmt");
//                       return nil, nil
//                 } () >>
//        | kwdIf SimpleStmt terminator Expression Block kwdElse Block
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdIf SimpleStmt terminator Expression Block kwdElse Block");
//                       return nil, nil
//                 } () >>
       ;
//
// // SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
// SwitchStmt : ExprSwitchStmt
//                 << func() (Attrib, error) {
//                       fmt.Println("ExprSwitchStmt");
//                       return nil, nil
//                 } () >>
//            | TypeSwitchStmt
//                << func() (Attrib, error) {
//                      fmt.Println("TypeSwitchStmt");
//                      return nil, nil
//                } () >>
//            ;
//
// // ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
// // ExprCaseClause = ExprSwitchCase ":" StatementList .
// // ExprSwitchCase = "case" ExpressionList | "default" .
// ExprSwitchStmt : kwdSwitch "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
//                | kwdSwitch Expression "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch Expression \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
//                | kwdSwitch SimpleStmt terminator "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch SimpleStmt terminator \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
//                | kwdSwitch SimpleStmt terminator Expression "{" RepeatTerminator RepeatExprCaseClause "}"
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdSwitch SimpleStmt terminator Expression \"{\" RepeatTerminator RepeatExprCaseClause \"}\"");
//                              return nil, nil
//                        } () >>
//                ;
//
// RepeatExprCaseClause : ExprCaseClause RepeatExprCaseClause
//                        << func() (Attrib, error) {
//                              fmt.Println("ExprCaseClause RepeatExprCaseClause");
//                              return nil, nil
//                        } () >>
//                      | empty
//                        << func() (Attrib, error) {
//                              fmt.Println("empty");
//                              return nil, nil
//                        } () >>
//                      ;
//
// // ExprCaseClause = ExprSwitchCase ":" StatementList .
// // ExprSwitchCase = "case" ExpressionList | "default" .
// ExprCaseClause : ExprSwitchCase ":" RepeatTerminator StatementList
//                        << func() (Attrib, error) {
//                              fmt.Println("ExprSwitchCase \":\" RepeatTerminator StatementList");
//                              return nil, nil
//                        } () >>
//                ;
//
// ExprSwitchCase : kwdCase ExpressionList
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdCase ExpressionList");
//                              return nil, nil
//                        } () >>
//                | kwdDefault
//                        << func() (Attrib, error) {
//                              fmt.Println("kwdDefault");
//                              return nil, nil
//                        } () >>
//                ;
//
// // TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
// // TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
// // TypeCaseClause  = TypeSwitchCase ":" StatementList .
// // TypeSwitchCase  = "case" TypeList | "default" .
// // TypeList        = Type { "," Type } .
// TypeSwitchStmt : kwdSwitch TypeSwitchGuard "{" RepeatTerminator RepeatTypeCaseClause "}"
//                       << func() (Attrib, error) {
//                             fmt.Println("kwdSwitch TypeSwitchGuard \"{\" RepeatTerminator RepeatTypeCaseClause \"}\"");
//                             return nil, nil
//                       } () >>
//                | kwdSwitch SimpleStmt terminator TypeSwitchGuard "{" RepeatTerminator RepeatTypeCaseClause "}"
//                      << func() (Attrib, error) {
//                            fmt.Println("kwdSwitch SimpleStmt terminator TypeSwitchGuard \"{\" RepeatTerminator RepeatTypeCaseClause \"}\"");
//                            return nil, nil
//                      } () >>
//                ;
//
// RepeatTypeCaseClause : TypeCaseClause RepeatTypeCaseClause
//                     << func() (Attrib, error) {
//                           fmt.Println("TypeCaseClause RepeatTypeCaseClause");
//                           return nil, nil
//                     } () >>
//                      | empty
//                      << func() (Attrib, error) {
//                            fmt.Println("empty");
//                            return nil, nil
//                      } () >>
//                      ;
//
// TypeSwitchGuard : PrimaryExpr "." "(" kwdType ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("PrimaryExpr \".\" \"(\" kwdType \")\"");
//                       return nil, nil
//                 } () >>
//                 | identifier shortAssign PrimaryExpr "." "(" kwdType ")"
//                 << func() (Attrib, error) {
//                       fmt.Println("identifier shortAssign PrimaryExpr \".\" \"(\" kwdType \")\"");
//                       return nil, nil
//                 } () >>
//                 ;
//
// TypeCaseClause : TypeSwitchCase ":" StatementList
//                 << func() (Attrib, error) {
//                       fmt.Println("TypeSwitchCase \":\" StatementList");
//                       return nil, nil
//                 } () >>
//                ;
//
// TypeSwitchCase : kwdCase TypeList
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdCase TypeList");
//                       return nil, nil
//                 } () >>
//                | kwdDefault
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdDefault");
//                       return nil, nil
//                 } () >>
//                ;
//
// TypeList : Type RepeatType
//                 << func() (Attrib, error) {
//                       fmt.Println("Type RepeatType");
//                       return nil, nil
//                 } () >>
//          ;
//
// RepeatType : "," Type RepeatType
//                 << func() (Attrib, error) {
//                       fmt.Println("\",\" Type RepeatType");
//                       return nil, nil
//                 } () >>
//            | empty
//                 << func() (Attrib, error) {
//                       fmt.Println("empty");
//                       return nil, nil
//                 } () >>
//            ;

// ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
// Condition = Expression .
ForStmt : kwdFor Block
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        startLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
                        n.code = append(n.code, $1.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                        return n, nil
                } () >>
        | kwdFor Condition Block
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        startLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
                        n.code = append(n.code, $1.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, $1.(Node).place))
                        n.code = append(n.code, $2.(Node).code...)
                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
        | kwdFor ForClause Block
                << func() (Attrib, error) {
                        n := Node{"", []string{}}
                        startLabel := NewLabel()
                        afterLabel := NewLabel()
                        n.code = append(n.code, $1.(Node).code[0]) // init statement
                        n.code = append(n.code, fmt.Sprintf("label, %s", startLabel))
                        n.code = append(n.code, $1.(Node).code[1]) // condition
                        n.code = append(n.code, fmt.Sprintf("blt, %s, %s, 1", afterLabel, $1.(Node).place))
                        n.code = append(n.code, $2.(Node).code...)
                        n.code = append(n.code, $1.(Node).code[2]) // post statement
                        n.code = append(n.code, fmt.Sprintf("j, %s", startLabel))
                        n.code = append(n.code, fmt.Sprintf("label, %s", afterLabel))
                        return n, nil
                } () >>
//         | kwdFor RangeClause Block
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdFor RangeClause Block");
//                       return nil, nil
//                 } () >>
        ;
//
// // RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .
// RangeClause : kwdRange Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("kwdRange Expression");
//                       return nil, nil
//                 } () >>
//             | ExpressionList "=" kwdRange Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("ExpressionList \"=\" kwdRange Expression");
//                       return nil, nil
//                 } () >>
//             | IdentifierList shortAssign kwdRange Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("IdentifierList shortAssign kwdRange Expression");
//                       return nil, nil
//                 } () >>
//             ;

// ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
// InitStmt = SimpleStmt .
// PostStmt = SimpleStmt .
// NOTE: The place value of ForClause contains the place value of the condition
// statement as that will be required in ForStmt to determine when to break. The
// place values of InitStmt and PostStmt will not be required.
// The code value of ForClause contains newline separated codes of InitStmt,
// Condition and PostStmt.
ForClause : terminator terminator
              << func() (Attrib, error) {
                      // When Condition is not specified, do an endless loop.
                      return Node{"1", []string{"", "", ""}}, nil
              } () >>
          | InitStmt terminator terminator
              << func() (Attrib, error) {
                      n := Node{"1", []string{}}
                      initStmtCode := ""
                      for _, v := range $0.(Node).code {
                              initStmtCode += v
                              initStmtCode += "\n"
                      }
                      n.code = append(n.code, initStmtCode)
                      n.code = append(n.code, "")
                      n.code = append(n.code, "")
                      return n, nil
              } () >>
          | terminator Condition terminator
              << func() (Attrib, error) {
                      n := Node{$1.(Node).place, []string{}}
                      condCode := ""
                      for _, v := range $1.(Node).code {
                              condCode += v
                              condCode += "\n"
                      }
                      n.code = append(n.code, "")
                      n.code = append(n.code, condCode)
                      n.code = append(n.code, "")
                      return n, nil
              } () >>
          | terminator terminator PostStmt
              << func() (Attrib, error) {
                      n := Node{"1", []string{}}
                      postStmtCode := ""
                      for _, v := range $2.(Node).code {
                              postStmtCode += v
                              postStmtCode += "\n"
                      }
                      n.code = append(n.code, "")
                      n.code = append(n.code, "")
                      n.code = append(n.code, postStmtCode)
                      return n, nil
              } () >>
          | InitStmt terminator Condition terminator
              << func() (Attrib, error) {
                      n := Node{$2.(Node).place, []string{}}
                      initStmtCode := ""
                      for _, v := range $0.(Node).code {
                              initStmtCode += v
                              initStmtCode += "\n"
                      }
                      condCode := ""
                      for _, v := range $2.(Node).code {
                              condCode += v
                              condCode += "\n"
                      }
                      n.code = append(n.code, initStmtCode)
                      n.code = append(n.code, condCode)
                      n.code = append(n.code, "")
                      return n, nil
              } () >>
          | InitStmt terminator terminator PostStmt
              << func() (Attrib, error) {
                      n := Node{"1", []string{}}
                      initStmtCode := ""
                      for _, v := range $0.(Node).code {
                              initStmtCode += v
                              initStmtCode += "\n"
                      }
                      postStmtCode := ""
                      for _, v := range $3.(Node).code {
                              postStmtCode += v
                              postStmtCode += "\n"
                      }
                      n.code = append(n.code, initStmtCode)
                      n.code = append(n.code, "")
                      n.code = append(n.code, postStmtCode)
                      return n, nil
              } () >>
          | terminator Condition terminator PostStmt
              << func() (Attrib, error) {
                      n := Node{$1.(Node).place, []string{}}
                      condCode := ""
                      for _, v := range $1.(Node).code {
                              condCode += v
                              condCode += "\n"
                      }
                      postStmtCode := ""
                      for _, v := range $3.(Node).code {
                              postStmtCode += v
                              postStmtCode += "\n"
                      }
                      n.code = append(n.code, "")
                      n.code = append(n.code, condCode)
                      n.code = append(n.code, postStmtCode)
                      return n, nil
              } () >>
          | InitStmt terminator Condition terminator PostStmt
              << func() (Attrib, error) {
                      n := Node{$2.(Node).place, []string{}}
                      initStmtCode := ""
                      for _, v := range $0.(Node).code {
                              initStmtCode += v
                              initStmtCode += "\n"
                      }
                      condCode := ""
                      for _, v := range $2.(Node).code {
                              condCode += v
                              condCode += "\n"
                      }
                      postStmtCode := ""
                      for _, v := range $4.(Node).code {
                              postStmtCode += v
                              postStmtCode += "\n"
                      }
                      n.code = append(n.code, initStmtCode)
                      n.code = append(n.code, condCode)
                      n.code = append(n.code, postStmtCode)
                      return n, nil
              } () >>
          ;

InitStmt : SimpleStmt
              << func() (Attrib, error) {
                      return Node{"", $0.(Node).code}, nil
              } () >>
         ;

PostStmt : SimpleStmt
              << func() (Attrib, error) {
                      return Node{"", $0.(Node).code}, nil
              } () >>
         ;

// FIXME: Condition can only be a binary expression.
Condition : Expression
              << func() (Attrib, error) {
                      return Node{$0.(Node).place, $0.(Node).code}, nil
              } () >>
          ;

// ExpressionStmt : Expression
//                 << func() (Attrib, error) {
//                       fmt.Println("Expression");
//                       return nil, nil
//                 } () >>
//                ;

IncDecStmt : Expression "++"
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, fmt.Sprintf("+, %s, %s, 1", $0.(Node).place, $0.(Node).place))
                        return n, nil
                } () >>
           | Expression "--"
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, fmt.Sprintf("-, %s, %s, 1", $0.(Node).place, $0.(Node).place))
                        return n, nil
                } () >>
           ;

Assignment : ExpressionList assignOp ExpressionList
                << func() (Attrib, error) {
                        op := string($1.(*token.Token).Lit)[0]
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        leftExpr := strings.Split($0.(Node).place, ",")
                        rightExpr := strings.Split($2.(Node).place, ",")
                        for k, v := range leftExpr {
                                n.code = append(n.code, fmt.Sprintf("%s, %s, %s, %s", op, v, v, rightExpr[k]))
                        }
                        return n, nil
                } () >>
           | ExpressionList "=" ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", $0.(Node).code}
                        n.code = append(n.code, $2.(Node).code...)
                        leftExpr := strings.Split($0.(Node).place, ",")
                        rightExpr := strings.Split($2.(Node).place, ",")
                        for k, v := range leftExpr {
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", v, rightExpr[k]))
                        }
                        return n, nil
                } () >>
           ;

ShortVarDecl : IdentifierList shortAssign ExpressionList
                << func() (Attrib, error) {
                        n := Node{"", $2.(Node).code}
                        expr := strings.Split($2.(Node).place, ",")
                        for k, v := range $0.(Node).code {
                                n.code = append(n.code, fmt.Sprintf("=, %s, %s", v, expr[k]))
                        }
                        return n, nil
                } () >>
             ;
Label : identifier
                 << func() (Attrib, error) {
                       return Node{string($0.(*token.Token).Lit), []string{}}, nil
                 } () >>
              ;
